---
description: Rust-specific coding standards for KNHKS
globs:
  - "rust/**/*.rs"
alwaysApply: false
---

# Rust Coding Standards

## Error Handling

- Use `Result<T, E>` for all fallible operations
- Never use `unwrap()` or `expect()` in production code paths
- Use `map_err()` to add context to errors
- Propagate errors with `?` operator when appropriate
- Provide meaningful error messages

## Feature Gating

- Use `#[cfg(feature = "...")]` for optional dependencies
- Support both `std` and `no_std` when possible
- Use `#[cfg(feature = "serde_json")]` for optional serialization

## Performance

- Use references (`&str`, `&[T]`) over owned types when possible
- Zero-copy when feasible
- Use `Box` only when necessary
- Prefer `Vec` over `String` for binary data

## Code Organization

- Keep modules focused and cohesive
- Use `pub` sparingly - only expose what's necessary
- Document public APIs with `///` doc comments
- Group related functionality together
- Use proper module structure with clear hierarchy
- Avoid wildcard imports in production code (`use crate::*`)

## Async/Sync Patterns

### ❌ NEVER make trait methods async - breaks dyn compatibility
```rust
// ❌ Bad: Async trait methods break dyn compatibility
pub trait ServicePlugin: Send + Sync {
    async fn start(&self) -> Result<ServiceHandle>; // BREAKS dyn ServicePlugin!
}

// ✅ Good: Keep trait methods sync, use async in implementations
pub trait ServicePlugin: Send + Sync {
    fn start(&self) -> Result<ServiceHandle>; // dyn compatible
}

// Implementation can still be async internally
impl ServicePlugin for MyPlugin {
    fn start(&self) -> Result<ServiceHandle> {
        tokio::task::block_in_place(|| {
            tokio::runtime::Handle::current().block_on(async {
                // Async operations here
                Ok(ServiceHandle::new())
            })
        })
    }
}
```

### ✅ Use async for I/O and long-running operations
- Use `async` for file operations, network, containers, database queries
- Use `sync` for pure computation and simple operations
- Never block async contexts with `std::thread::sleep` - use `tokio::time::sleep` instead

## Trait Design

- Keep traits `dyn` compatible - never use async trait methods
- Use sync methods in traits, implement async internally if needed
- Prefer composition over complex trait hierarchies
- Maintain backward compatibility - add new methods instead of changing existing ones

## Testing

- Write unit tests for all public APIs
- Test error paths
- Test guard constraint violations
- Use property-based testing where appropriate
- **Test behaviors, not implementation details** - Focus on what code does, not how
- Use AAA pattern (Arrange, Act, Assert) for clarity
- Use descriptive test names that explain what is being tested
- Use proper async test functions (`#[tokio::test]`) for async operations
- Prefer real collaborators over mocks when possible

## Examples

### BAD: Unhandled Error
```rust
fn process(input: &str) -> u64 {
    input.parse().unwrap()
}
```

### GOOD: Proper Error Handling
```rust
fn process(input: &str) -> Result<u64, ProcessingError> {
    if input.is_empty() {
        return Err(ProcessingError::EmptyInput);
    }
    
    input.parse()
        .map_err(|e| ProcessingError::ParseFailed(e.to_string()))
}
```
