//! Generated Hook Functions from Workflow Ontology
//!
//! Auto-generated by ggen from RDF/Turtle workflow specification
//! Source ontology: {{workflow_id}}
//! Generation timestamp: {{generation_timestamp}}
//!
//! Hooks integrate with KNHK's knowledge hook system

use crate::error::{WorkflowError, WorkflowResult};
use serde_json::Value;
use std::collections::HashMap;
use tracing::{debug, info, span, Level};

/// Hook context for workflow: {{workflow_name}}
#[derive(Debug, Clone)]
pub struct {{pascal_case workflow_name}}HookContext {
    /// Workflow instance ID
    pub instance_id: String,
    /// Current task
    pub current_task: Option<String>,
    /// Workflow data
    pub data: HashMap<String, Value>,
    /// Execution metadata
    pub metadata: HashMap<String, String>,
}

impl {{pascal_case workflow_name}}HookContext {
    /// Create new hook context
    pub fn new(instance_id: String) -> Self {
        Self {
            instance_id,
            current_task: None,
            data: HashMap::new(),
            metadata: HashMap::new(),
        }
    }
}

{{#each hooks}}
/// Hook: {{this.name}}
///
/// **Trigger**: {{this.trigger}}
/// **Description**: {{this.description}}
/// **Pattern**: {{this.yawl_pattern}}
///
/// Generated from ontology:
/// - URI: {{this.uri}}
/// - Guards: {{#if this.guards}}{{#each this.guards}}{{this}}, {{/each}}{{else}}None{{/if}}
pub async fn {{snake_case this.name}}_hook(
    context: &mut {{pascal_case ../workflow_name}}HookContext,
    input: Value,
) -> WorkflowResult<Value> {
    let _span = span!(Level::INFO, "hook",
        hook_name = "{{this.name}}",
        instance_id = %context.instance_id,
        trigger = "{{this.trigger}}"
    ).entered();

    info!("Executing hook: {{this.name}}");
    debug!("Input: {:?}", input);

    {{#if this.guards}}
    // Check guards before execution
    {{#each this.guards}}
    if !check_guard_{{snake_case this}}(context)? {
        return Err(WorkflowError::GuardCheckFailed {
            guard: "{{this}}".to_string(),
            transition: "{{../name}}".to_string(),
        });
    }
    {{/each}}
    {{/if}}

    {{#if this.pre_conditions}}
    // Validate pre-conditions
    {{#each this.pre_conditions}}
    // Condition: {{this.expression}}
    {{/each}}
    {{/if}}

    // Execute hook logic
    {{#if this.sparql_query}}
    // SPARQL Query: {{this.sparql_query}}
    // TODO: Execute query against knowledge graph
    {{/if}}

    {{#if this.action}}
    // Action: {{this.action}}
    {{/if}}

    // TODO: Implement actual hook logic
    let output = serde_json::json!({
        "hook": "{{this.name}}",
        "status": "executed",
        "timestamp": std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_secs()
    });

    {{#if this.post_conditions}}
    // Validate post-conditions
    {{#each this.post_conditions}}
    // Condition: {{this.expression}}
    {{/each}}
    {{/if}}

    info!("Hook {{this.name}} completed successfully");
    debug!("Output: {:?}", output);

    Ok(output)
}

{{#if this.guards}}
{{#each this.guards}}
/// Guard check for: {{this}}
fn check_guard_{{snake_case this}}(context: &{{pascal_case ../../workflow_name}}HookContext) -> WorkflowResult<bool> {
    debug!("Checking guard: {{this}}");
    // TODO: Implement guard logic
    // Access context.data, context.metadata for guard evaluation
    Ok(true)
}
{{/each}}
{{/if}}

{{/each}}

/// Register all hooks with workflow engine
pub fn register_{{snake_case workflow_name}}_hooks() -> HashMap<String, Box<dyn Fn(&mut {{pascal_case workflow_name}}HookContext, Value) -> WorkflowResult<Value>>> {
    let mut hooks: HashMap<String, Box<dyn Fn(&mut {{pascal_case workflow_name}}HookContext, Value) -> WorkflowResult<Value>>> = HashMap::new();

    {{#each hooks}}
    // Note: Async hooks need runtime context - this is simplified
    // In production, use tokio::spawn or similar async runtime
    {{/each}}

    hooks
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_hooks_execute() {
        let mut context = {{pascal_case workflow_name}}HookContext::new("test-instance".to_string());
        let input = serde_json::json!({"test": "data"});

        {{#each hooks}}
        {
            let result = {{snake_case this.name}}_hook(&mut context, input.clone()).await;
            assert!(result.is_ok(), "Hook {{this.name}} should execute successfully");
        }
        {{/each}}
    }
}
