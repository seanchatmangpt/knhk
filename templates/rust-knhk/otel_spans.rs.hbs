//! Generated OpenTelemetry Span Registration
//!
//! Auto-generated by ggen from RDF/Turtle workflow specification
//! Source ontology: {{workflow_id}}
//! Generation timestamp: {{generation_timestamp}}
//!
//! Registers all spans, metrics, and events for OTEL observability

use opentelemetry::{
    metrics::{Counter, Histogram, Meter},
    trace::{Span, Tracer},
    KeyValue,
};
use std::time::Duration;

/// OTEL metrics for workflow: {{workflow_name}}
pub struct {{pascal_case workflow_name}}Metrics {
    /// Task execution counter
    pub task_executions: Counter<u64>,
    /// Task duration histogram
    pub task_duration: Histogram<f64>,
    /// Workflow completion counter
    pub workflow_completions: Counter<u64>,
    /// Guard check counter
    pub guard_checks: Counter<u64>,
    /// Hook execution counter
    pub hook_executions: Counter<u64>,
    /// Error counter
    pub errors: Counter<u64>,
}

impl {{pascal_case workflow_name}}Metrics {
    /// Initialize metrics
    pub fn new(meter: &Meter) -> Self {
        Self {
            task_executions: meter
                .u64_counter("{{snake_case workflow_name}}.task.executions")
                .with_description("Number of task executions")
                .init(),
            task_duration: meter
                .f64_histogram("{{snake_case workflow_name}}.task.duration")
                .with_description("Task execution duration in milliseconds")
                .with_unit("ms")
                .init(),
            workflow_completions: meter
                .u64_counter("{{snake_case workflow_name}}.workflow.completions")
                .with_description("Number of workflow completions")
                .init(),
            guard_checks: meter
                .u64_counter("{{snake_case workflow_name}}.guard.checks")
                .with_description("Number of guard checks performed")
                .init(),
            hook_executions: meter
                .u64_counter("{{snake_case workflow_name}}.hook.executions")
                .with_description("Number of hook executions")
                .init(),
            errors: meter
                .u64_counter("{{snake_case workflow_name}}.errors")
                .with_description("Number of errors encountered")
                .init(),
        }
    }

    /// Record task execution
    pub fn record_task_execution(&self, task_name: &str, duration: Duration, success: bool) {
        let attributes = vec![
            KeyValue::new("task.name", task_name.to_string()),
            KeyValue::new("task.success", success),
            KeyValue::new("workflow.name", "{{workflow_name}}"),
        ];

        self.task_executions.add(1, &attributes);
        self.task_duration.record(duration.as_secs_f64() * 1000.0, &attributes);
    }

    /// Record workflow completion
    pub fn record_workflow_completion(&self, success: bool, duration: Duration) {
        let attributes = vec![
            KeyValue::new("workflow.name", "{{workflow_name}}"),
            KeyValue::new("workflow.success", success),
        ];

        self.workflow_completions.add(1, &attributes);
    }

    /// Record guard check
    pub fn record_guard_check(&self, guard_name: &str, passed: bool) {
        let attributes = vec![
            KeyValue::new("guard.name", guard_name.to_string()),
            KeyValue::new("guard.passed", passed),
            KeyValue::new("workflow.name", "{{workflow_name}}"),
        ];

        self.guard_checks.add(1, &attributes);
    }

    /// Record hook execution
    pub fn record_hook_execution(&self, hook_name: &str, duration: Duration, success: bool) {
        let attributes = vec![
            KeyValue::new("hook.name", hook_name.to_string()),
            KeyValue::new("hook.success", success),
            KeyValue::new("workflow.name", "{{workflow_name}}"),
        ];

        self.hook_executions.add(1, &attributes);
    }

    /// Record error
    pub fn record_error(&self, error_type: &str, context: &str) {
        let attributes = vec![
            KeyValue::new("error.type", error_type.to_string()),
            KeyValue::new("error.context", context.to_string()),
            KeyValue::new("workflow.name", "{{workflow_name}}"),
        ];

        self.errors.add(1, &attributes);
    }
}

/// Span definitions for all workflow operations
pub mod spans {
    use opentelemetry::trace::{Span, Tracer};
    use opentelemetry::KeyValue;

    {{#each tasks}}
    /// Create span for task: {{this.name}}
    pub fn {{snake_case this.name}}_span<T: Tracer>(tracer: &T) -> impl Span {
        tracer.start_with_attributes(
            "{{../workflow_name}}.task.{{snake_case this.name}}",
            vec![
                KeyValue::new("task.name", "{{this.name}}"),
                KeyValue::new("task.type", "{{this.task_type}}"),
                KeyValue::new("task.pattern", "{{this.yawl_pattern}}"),
                KeyValue::new("workflow.name", "{{../workflow_name}}"),
            ],
        )
    }
    {{/each}}

    {{#each hooks}}
    /// Create span for hook: {{this.name}}
    pub fn {{snake_case this.name}}_hook_span<T: Tracer>(tracer: &T) -> impl Span {
        tracer.start_with_attributes(
            "{{../workflow_name}}.hook.{{snake_case this.name}}",
            vec![
                KeyValue::new("hook.name", "{{this.name}}"),
                KeyValue::new("hook.trigger", "{{this.trigger}}"),
                KeyValue::new("workflow.name", "{{../workflow_name}}"),
            ],
        )
    }
    {{/each}}

    /// Create span for workflow execution
    pub fn workflow_execution_span<T: Tracer>(tracer: &T, instance_id: &str) -> impl Span {
        tracer.start_with_attributes(
            "{{workflow_name}}.workflow.execution",
            vec![
                KeyValue::new("workflow.name", "{{workflow_name}}"),
                KeyValue::new("workflow.instance_id", instance_id.to_string()),
            ],
        )
    }

    /// Create span for state transition
    pub fn state_transition_span<T: Tracer>(
        tracer: &T,
        from_state: &str,
        to_state: &str,
        event: &str,
    ) -> impl Span {
        tracer.start_with_attributes(
            "{{workflow_name}}.state.transition",
            vec![
                KeyValue::new("state.from", from_state.to_string()),
                KeyValue::new("state.to", to_state.to_string()),
                KeyValue::new("state.event", event.to_string()),
                KeyValue::new("workflow.name", "{{workflow_name}}"),
            ],
        )
    }
}

/// Event definitions for workflow operations
pub mod events {
    use opentelemetry::trace::Span;
    use opentelemetry::KeyValue;

    {{#each events}}
    /// Record event: {{this.name}}
    pub fn record_{{snake_case this.name}}_event(span: &mut dyn Span, {{#each this.attributes}}{{snake_case this.name}}: {{this.type}},{{/each}}) {
        span.add_event(
            "{{this.name}}",
            vec![
                {{#each this.attributes}}
                KeyValue::new("{{this.name}}", {{snake_case this.name}}.to_string()),
                {{/each}}
            ],
        );
    }
    {{/each}}
}

#[cfg(test)]
mod tests {
    use super::*;
    use opentelemetry::global;

    #[test]
    fn test_metrics_initialization() {
        let meter = global::meter("test");
        let metrics = {{pascal_case workflow_name}}Metrics::new(&meter);

        // Record some test metrics
        metrics.record_task_execution("test_task", Duration::from_millis(100), true);
        metrics.record_workflow_completion(true, Duration::from_secs(1));
        metrics.record_guard_check("test_guard", true);
        metrics.record_hook_execution("test_hook", Duration::from_millis(50), true);
    }
}
