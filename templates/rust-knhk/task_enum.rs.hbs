//! Generated Task Enum from YAWL Workflow Ontology
//!
//! Auto-generated by ggen from RDF/Turtle workflow specification
//! Source ontology: {{workflow_id}}
//! Generation timestamp: {{generation_timestamp}}
//!
//! DO NOT EDIT MANUALLY - regenerate using:
//! npx ggen generate --template rust-knhk/task_enum.rs.hbs --ontology {{ontology_path}}

use serde::{Deserialize, Serialize};
use std::fmt;

/// Task enumeration for workflow: {{workflow_name}}
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum {{pascal_case workflow_name}}Task {
    {{#each tasks}}
    /// {{this.description}}
    ///
    /// **Type**: {{this.task_type}}
    /// **Pattern**: {{this.yawl_pattern}}
    /// **Guards**: {{#if this.guards}}{{#each this.guards}}{{this}}, {{/each}}{{else}}None{{/if}}
    {{pascal_case this.name}},
    {{/each}}
}

impl {{pascal_case workflow_name}}Task {
    /// Get task name as string
    pub fn as_str(&self) -> &'static str {
        match self {
            {{#each tasks}}
            Self::{{pascal_case this.name}} => "{{this.name}}",
            {{/each}}
        }
    }

    /// Get task ID (from ontology)
    pub fn task_id(&self) -> &'static str {
        match self {
            {{#each tasks}}
            Self::{{pascal_case this.name}} => "{{this.id}}",
            {{/each}}
        }
    }

    /// Get YAWL pattern type
    pub fn yawl_pattern(&self) -> &'static str {
        match self {
            {{#each tasks}}
            Self::{{pascal_case this.name}} => "{{this.yawl_pattern}}",
            {{/each}}
        }
    }

    /// Check if task has guards
    pub fn has_guards(&self) -> bool {
        match self {
            {{#each tasks}}
            Self::{{pascal_case this.name}} => {{#if this.guards}}true{{else}}false{{/if}},
            {{/each}}
        }
    }

    /// Get guard check function name
    pub fn guard_fn(&self) -> Option<&'static str> {
        match self {
            {{#each tasks}}
            {{#if this.guards}}
            Self::{{pascal_case this.name}} => Some("check_{{snake_case this.name}}_guards"),
            {{else}}
            Self::{{pascal_case this.name}} => None,
            {{/if}}
            {{/each}}
        }
    }

    /// All tasks in workflow
    pub fn all() -> Vec<Self> {
        vec![
            {{#each tasks}}
            Self::{{pascal_case this.name}},
            {{/each}}
        ]
    }
}

impl fmt::Display for {{pascal_case workflow_name}}Task {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

/// Task metadata for workflow introspection
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TaskMetadata {
    pub id: String,
    pub name: String,
    pub task_type: String,
    pub yawl_pattern: String,
    pub description: String,
    pub guards: Vec<String>,
    pub inputs: Vec<String>,
    pub outputs: Vec<String>,
}

impl {{pascal_case workflow_name}}Task {
    /// Get full metadata for this task
    pub fn metadata(&self) -> TaskMetadata {
        match self {
            {{#each tasks}}
            Self::{{pascal_case this.name}} => TaskMetadata {
                id: "{{this.id}}".to_string(),
                name: "{{this.name}}".to_string(),
                task_type: "{{this.task_type}}".to_string(),
                yawl_pattern: "{{this.yawl_pattern}}".to_string(),
                description: "{{this.description}}".to_string(),
                guards: vec![{{#each this.guards}}"{{this}}".to_string(),{{/each}}],
                inputs: vec![{{#each this.inputs}}"{{this}}".to_string(),{{/each}}],
                outputs: vec![{{#each this.outputs}}"{{this}}".to_string(),{{/each}}],
            },
            {{/each}}
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_all_tasks_unique() {
        let tasks = {{pascal_case workflow_name}}Task::all();
        let mut seen = std::collections::HashSet::new();
        for task in tasks {
            assert!(seen.insert(task.task_id()), "Duplicate task ID: {}", task.task_id());
        }
    }

    #[test]
    fn test_task_metadata() {
        {{#each tasks}}
        {
            let task = {{pascal_case ../workflow_name}}Task::{{pascal_case this.name}};
            let metadata = task.metadata();
            assert_eq!(metadata.name, "{{this.name}}");
            assert_eq!(metadata.yawl_pattern, "{{this.yawl_pattern}}");
        }
        {{/each}}
    }
}
