//! Generated State Machine from YAWL Workflow Graph
//!
//! Auto-generated by ggen from RDF/Turtle workflow specification
//! Source ontology: {{workflow_id}}
//! Generation timestamp: {{generation_timestamp}}
//!
//! State machine implements workflow transitions with guard checks

use crate::error::{WorkflowError, WorkflowResult};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use tracing::{debug, info, warn};

/// Workflow state for: {{workflow_name}}
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum {{pascal_case workflow_name}}State {
    {{#each states}}
    /// {{this.description}}
    {{pascal_case this.name}},
    {{/each}}
}

impl {{pascal_case workflow_name}}State {
    /// Get state name
    pub fn as_str(&self) -> &'static str {
        match self {
            {{#each states}}
            Self::{{pascal_case this.name}} => "{{this.name}}",
            {{/each}}
        }
    }

    /// Check if this is a final state
    pub fn is_final(&self) -> bool {
        matches!(self,
            {{#each states}}
            {{#if this.is_final}}
            Self::{{pascal_case this.name}}{{#unless @last}} |{{/unless}}
            {{/if}}
            {{/each}}
        )
    }

    /// Check if this is an error state
    pub fn is_error(&self) -> bool {
        matches!(self,
            {{#each states}}
            {{#if this.is_error}}
            Self::{{pascal_case this.name}}{{#unless @last}} |{{/unless}}
            {{/if}}
            {{/each}}
        )
    }
}

/// State transition event
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StateTransition {
    pub from: {{pascal_case workflow_name}}State,
    pub to: {{pascal_case workflow_name}}State,
    pub event: String,
    pub timestamp: std::time::SystemTime,
    pub context: HashMap<String, String>,
}

/// State machine for workflow
pub struct {{pascal_case workflow_name}}StateMachine {
    current_state: {{pascal_case workflow_name}}State,
    context: HashMap<String, String>,
    history: Vec<StateTransition>,
}

impl {{pascal_case workflow_name}}StateMachine {
    /// Create new state machine
    pub fn new() -> Self {
        Self {
            current_state: {{pascal_case workflow_name}}State::{{pascal_case initial_state}},
            context: HashMap::new(),
            history: Vec::new(),
        }
    }

    /// Get current state
    pub fn current_state(&self) -> &{{pascal_case workflow_name}}State {
        &self.current_state
    }

    /// Set context variable
    pub fn set_context(&mut self, key: String, value: String) {
        self.context.insert(key, value);
    }

    /// Get context variable
    pub fn get_context(&self, key: &str) -> Option<&String> {
        self.context.get(key)
    }

    /// Get transition history
    pub fn history(&self) -> &[StateTransition] {
        &self.history
    }

    /// Attempt state transition
    pub fn transition(&mut self, event: &str) -> WorkflowResult<()> {
        let from_state = self.current_state.clone();
        let to_state = self.next_state(event)?;

        // Check guards before transition
        self.check_guards(&from_state, &to_state, event)?;

        info!(
            "Transitioning from {} to {} on event {}",
            from_state.as_str(),
            to_state.as_str(),
            event
        );

        // Record transition
        self.history.push(StateTransition {
            from: from_state.clone(),
            to: to_state.clone(),
            event: event.to_string(),
            timestamp: std::time::SystemTime::now(),
            context: self.context.clone(),
        });

        self.current_state = to_state;
        Ok(())
    }

    /// Determine next state based on event
    fn next_state(&self, event: &str) -> WorkflowResult<{{pascal_case workflow_name}}State> {
        match (&self.current_state, event) {
            {{#each transitions}}
            ({{pascal_case ../workflow_name}}State::{{pascal_case this.from}}, "{{this.event}}") => {
                Ok({{pascal_case ../workflow_name}}State::{{pascal_case this.to}})
            }
            {{/each}}
            _ => Err(WorkflowError::InvalidTransition {
                from: self.current_state.as_str().to_string(),
                event: event.to_string(),
            }),
        }
    }

    /// Check transition guards
    fn check_guards(
        &self,
        from: &{{pascal_case workflow_name}}State,
        to: &{{pascal_case workflow_name}}State,
        event: &str,
    ) -> WorkflowResult<()> {
        match (from, to, event) {
            {{#each transitions}}
            {{#if this.guards}}
            (
                {{pascal_case ../workflow_name}}State::{{pascal_case this.from}},
                {{pascal_case ../workflow_name}}State::{{pascal_case this.to}},
                "{{this.event}}"
            ) => {
                // Check guards for this transition
                {{#each this.guards}}
                if !self.check_guard_{{snake_case this}}()? {
                    warn!("Guard {{this}} failed for transition {} -> {}", "{{../from}}", "{{../to}}");
                    return Err(WorkflowError::GuardCheckFailed {
                        guard: "{{this}}".to_string(),
                        transition: format!("{} -> {}", "{{../from}}", "{{../to}}"),
                    });
                }
                {{/each}}
                Ok(())
            }
            {{/if}}
            {{/each}}
            _ => Ok(()), // No guards for this transition
        }
    }

    {{#each guard_functions}}
    /// Guard check: {{this.description}}
    fn check_guard_{{snake_case this.name}}(&self) -> WorkflowResult<bool> {
        debug!("Checking guard: {{this.name}}");

        {{#if this.sparql_query}}
        // Execute SPARQL guard check
        // Query: {{this.sparql_query}}
        {{/if}}

        {{#if this.condition}}
        // Condition: {{this.condition}}
        {{/if}}

        // TODO: Implement actual guard logic
        // For now, return true (guard passes)
        Ok(true)
    }
    {{/each}}
}

impl Default for {{pascal_case workflow_name}}StateMachine {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_initial_state() {
        let sm = {{pascal_case workflow_name}}StateMachine::new();
        assert_eq!(sm.current_state(), &{{pascal_case workflow_name}}State::{{pascal_case initial_state}});
    }

    #[test]
    fn test_valid_transitions() {
        let mut sm = {{pascal_case workflow_name}}StateMachine::new();

        {{#each test_transitions}}
        sm.transition("{{this.event}}").expect("Valid transition should succeed");
        assert_eq!(sm.current_state(), &{{pascal_case ../workflow_name}}State::{{pascal_case this.expected_state}});
        {{/each}}
    }

    #[test]
    fn test_invalid_transition() {
        let mut sm = {{pascal_case workflow_name}}StateMachine::new();
        let result = sm.transition("invalid_event");
        assert!(result.is_err());
    }

    #[test]
    fn test_history_tracking() {
        let mut sm = {{pascal_case workflow_name}}StateMachine::new();
        sm.transition("start").ok();
        assert_eq!(sm.history().len(), 1);
    }
}
