//! Code Generation CLI Commands (ggen v2.7.1)
//!
//! Provides CLI interface for code generation operations:
//! - gen workflow: Generate Rust workflow from RDF/Turtle specification
//! - gen tests: Generate Chicago TDD tests from specification
//! - gen hook: Generate knowledge hook from RDF definition
//! - gen validate: Validate generated code against schema
//! - gen templates: Manage code generation templates
//! - gen marketplace: Marketplace integration for templates

// Allow non_upper_case_globals - #[verb] macro generates static vars with lowercase names
#![allow(non_upper_case_globals)]

use crate::commands::gen as gen_impl;
use clap;
use clap_noun_verb::Result as CnvResult;
use clap_noun_verb_macros::verb;
use serde::{Deserialize, Serialize};
use std::path::PathBuf;

#[cfg(feature = "otel")]
use tracing::instrument;

/// Output format for structured data
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum OutputFormat {
    Json,
    Yaml,
    Text,
}

impl Default for OutputFormat {
    fn default() -> Self {
        Self::Text
    }
}

impl std::str::FromStr for OutputFormat {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s.to_lowercase().as_str() {
            "json" => Ok(Self::Json),
            "yaml" => Ok(Self::Yaml),
            "text" => Ok(Self::Text),
            _ => Err(format!(
                "Invalid format: {}. Valid options: json, yaml, text",
                s
            )),
        }
    }
}

/// Target language for code generation
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum Language {
    Rust,
    Python,
    JavaScript,
    Go,
}

impl Default for Language {
    fn default() -> Self {
        Self::Rust
    }
}

impl std::str::FromStr for Language {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s.to_lowercase().as_str() {
            "rust" => Ok(Self::Rust),
            "python" | "py" => Ok(Self::Python),
            "javascript" | "js" => Ok(Self::JavaScript),
            "go" | "golang" => Ok(Self::Go),
            _ => Err(format!(
                "Invalid language: {}. Valid options: rust, python, js, go",
                s
            )),
        }
    }
}

#[derive(Serialize, Debug)]
struct WorkflowGenResult {
    spec_file: String,
    output_file: Option<String>,
    language: String,
    telemetry_enabled: bool,
    hooks_enabled: bool,
    validated: bool,
}

/// Generate Rust workflow from RDF/Turtle specification
///
/// # Examples
///
/// ```bash
/// # Generate workflow from Turtle file
/// knhk gen workflow spec.ttl
///
/// # Generate with specific output file
/// knhk gen workflow spec.ttl --output workflow.rs
///
/// # Generate for Python with telemetry
/// knhk gen workflow spec.ttl --language python --emit-telemetry
///
/// # Validate against Weaver schema
/// knhk gen workflow spec.ttl --validate --emit-telemetry
/// ```
#[cfg_attr(
    feature = "otel",
    instrument(
        skip_all,
        fields(
            operation = "knhk.gen.workflow",
            spec_file = %spec_file.display(),
            language = ?language
        )
    )
)]
#[verb]
pub fn workflow(
    spec_file: PathBuf,

    #[clap(long)] template: Option<PathBuf>,

    #[clap(long, short = 'o')] output: Option<PathBuf>,

    #[clap(long, short = 'l', default_value = "rust")] language: Language,

    #[clap(long)] validate: bool,

    #[clap(long)] emit_hooks: bool,

    #[clap(long)] emit_telemetry: bool,

    #[clap(long, default_value = "text")] format: OutputFormat,
) -> CnvResult<WorkflowGenResult> {
    gen_impl::generate_workflow(gen_impl::WorkflowGenRequest {
        spec_file,
        template,
        output,
        language,
        validate,
        emit_hooks,
        emit_telemetry,
        format,
    })
}

#[derive(Serialize, Debug)]
struct TestsGenResult {
    spec_file: String,
    output_dir: String,
    language: String,
    coverage_target: u8,
    test_count: usize,
}

/// Generate Chicago TDD tests from specification
///
/// # Examples
///
/// ```bash
/// # Generate tests from specification
/// knhk gen tests spec.ttl
///
/// # Generate with custom output directory
/// knhk gen tests spec.ttl --output ./tests
///
/// # Generate with 95% coverage target
/// knhk gen tests spec.ttl --coverage 95
///
/// # Generate Python tests
/// knhk gen tests spec.ttl --language python
/// ```
#[cfg_attr(
    feature = "otel",
    instrument(
        skip_all,
        fields(
            operation = "knhk.gen.tests",
            spec_file = %spec_file.display(),
            coverage = coverage
        )
    )
)]
#[verb]
pub fn tests(
    spec_file: PathBuf,

    #[clap(long)] template: Option<PathBuf>,

    #[clap(long, short = 'o')] output: Option<PathBuf>,

    #[clap(long, short = 'c', default_value = "90")] coverage: u8,

    #[clap(long, short = 'l', default_value = "rust")] language: Language,

    #[clap(long, default_value = "text")] format: OutputFormat,
) -> CnvResult<TestsGenResult> {
    gen_impl::generate_tests(gen_impl::TestsGenRequest {
        spec_file,
        template,
        output,
        coverage,
        language,
        format,
    })
}

#[derive(Serialize, Debug)]
struct HookGenResult {
    definition_file: String,
    output_file: Option<String>,
    lockchain_enabled: bool,
    telemetry_enabled: bool,
}

/// Generate knowledge hook from RDF definition
///
/// # Examples
///
/// ```bash
/// # Generate hook from definition
/// knhk gen hook hook-def.ttl
///
/// # Generate with Lockchain receipts
/// knhk gen hook hook-def.ttl --with-lockchain
///
/// # Generate with OTEL telemetry
/// knhk gen hook hook-def.ttl --with-telemetry
///
/// # Generate with custom template
/// knhk gen hook hook-def.ttl --template custom-hook.tmpl
/// ```
#[cfg_attr(
    feature = "otel",
    instrument(
        skip_all,
        fields(
            operation = "knhk.gen.hook",
            definition = %definition_file.display()
        )
    )
)]
#[verb]
pub fn hook(
    definition_file: PathBuf,

    #[clap(long)] template: Option<PathBuf>,

    #[clap(long, short = 'o')] output: Option<PathBuf>,

    #[clap(long)] with_lockchain: bool,

    #[clap(long)] with_telemetry: bool,

    #[clap(long, default_value = "text")] format: OutputFormat,
) -> CnvResult<HookGenResult> {
    gen_impl::generate_hook(gen_impl::HookGenRequest {
        definition_file,
        template,
        output,
        with_lockchain,
        with_telemetry,
        format,
    })
}

#[derive(Serialize, Debug)]
struct ValidateResult {
    code_path: String,
    schema_valid: bool,
    telemetry_valid: bool,
    performance_valid: bool,
    weaver_valid: bool,
    issues: Vec<String>,
    warnings: Vec<String>,
}

/// Validate generated code against schema
///
/// # Examples
///
/// ```bash
/// # Validate generated code
/// knhk gen validate ./src/workflow.rs
///
/// # Validate with custom schema
/// knhk gen validate ./src/workflow.rs --schema custom.yaml
///
/// # Validate telemetry compliance
/// knhk gen validate ./src/workflow.rs --telemetry
///
/// # Check performance constraints
/// knhk gen validate ./src/workflow.rs --performance
///
/// # Run Weaver validation (source of truth)
/// knhk gen validate ./src/workflow.rs --weaver
/// ```
#[cfg_attr(
    feature = "otel",
    instrument(
        skip_all,
        fields(
            operation = "knhk.gen.validate",
            code_path = %code_path.display()
        )
    )
)]
#[verb]
pub fn validate(
    code_path: PathBuf,

    #[clap(long)] schema: Option<PathBuf>,

    #[clap(long)] telemetry: bool,

    #[clap(long)] performance: bool,

    #[clap(long)] weaver: bool,

    #[clap(long, default_value = "text")] format: OutputFormat,
) -> CnvResult<ValidateResult> {
    gen_impl::validate_code(gen_impl::ValidateRequest {
        code_path,
        schema,
        telemetry,
        performance,
        weaver,
        format,
    })
}

/// Template management commands
pub mod templates {
    use super::*;

    #[derive(Serialize, Debug)]
    struct TemplateListResult {
        templates: Vec<TemplateInfo>,
        total_count: usize,
    }

    #[derive(Serialize, Debug)]
    struct TemplateInfo {
        name: String,
        version: String,
        description: String,
        language: String,
        category: String,
    }

    ///

    ///

    ///

    #[cfg_attr(
        feature = "otel",
        instrument(skip_all, fields(operation = "knhk.gen.templates.list"))
    )]
    #[verb]
    pub fn list(
        #[clap(long, default_value = "text")] format: OutputFormat,
    ) -> CnvResult<TemplateListResult> {
        gen_impl::templates::list_templates(format)
    }

    #[derive(Serialize, Debug)]
    struct TemplateSearchResult {
        matches: Vec<TemplateInfo>,
        match_count: usize,
    }

    ///

    ///

    ///

    #[cfg_attr(
        feature = "otel",
        instrument(skip_all, fields(operation = "knhk.gen.templates.search", pattern = %pattern))
    )]
    #[verb]
    pub fn search(
        pattern: String,
        #[clap(long, default_value = "text")] format: OutputFormat,
    ) -> CnvResult<TemplateSearchResult> {
        gen_impl::templates::search_templates(pattern, format)
    }

    #[derive(Serialize, Debug)]
    struct TemplatePreviewResult {
        template_name: String,
        preview: String,
    }

    ///

    ///

    ///

    #[cfg_attr(
        feature = "otel",
        instrument(skip_all, fields(operation = "knhk.gen.templates.preview", template = %template))
    )]
    #[verb]
    pub fn preview(
        template: String,
        #[clap(long, default_value = "text")] format: OutputFormat,
    ) -> CnvResult<TemplatePreviewResult> {
        gen_impl::templates::preview_template(template, format)
    }

    #[derive(Serialize, Debug)]
    struct TemplateInstallResult {
        name: String,
        version: String,
        installed_path: String,
    }

    ///

    ///

    ///

    #[cfg_attr(
        feature = "otel",
        instrument(skip_all, fields(operation = "knhk.gen.templates.install", name = %name))
    )]
    #[verb]
    pub fn install(
        name: String,
        #[clap(long, default_value = "text")] format: OutputFormat,
    ) -> CnvResult<TemplateInstallResult> {
        gen_impl::templates::install_template(name, format)
    }

    #[derive(Serialize, Debug)]
    struct TemplateValidateResult {
        template_path: String,
        valid: bool,
        issues: Vec<String>,
    }

    ///

    ///

    #[cfg_attr(
        feature = "otel",
        instrument(skip_all, fields(operation = "knhk.gen.templates.validate", path = %path.display()))
    )]
    #[verb]
    pub fn validate(
        path: PathBuf,
        #[clap(long, default_value = "text")] format: OutputFormat,
    ) -> CnvResult<TemplateValidateResult> {
        gen_impl::templates::validate_template(path, format)
    }

    #[derive(Serialize, Debug)]
    struct TemplateDocsResult {
        name: String,
        documentation: String,
    }

    ///

    ///

    #[cfg_attr(
        feature = "otel",
        instrument(skip_all, fields(operation = "knhk.gen.templates.docs", name = %name))
    )]
    #[verb]
    pub fn docs(
        name: String,
        #[clap(long, default_value = "text")] format: OutputFormat,
    ) -> CnvResult<TemplateDocsResult> {
        gen_impl::templates::show_docs(name, format)
    }
}

/// Marketplace integration commands
pub mod marketplace {
    use super::*;

    #[derive(Serialize, Debug)]
    struct PublishResult {
        template_name: String,
        version: String,
        marketplace_url: String,
    }

    ///

    ///

    #[cfg_attr(
        feature = "otel",
        instrument(skip_all, fields(operation = "knhk.gen.marketplace.publish", template = %template.display()))
    )]
    #[verb]
    pub fn publish(
        template: PathBuf,
        #[clap(long, default_value = "text")] format: OutputFormat,
    ) -> CnvResult<PublishResult> {
        gen_impl::marketplace::publish_template(template, format)
    }

    #[derive(Serialize, Debug)]
    struct MarketplaceSearchResult {
        matches: Vec<MarketplaceTemplate>,
        match_count: usize,
    }

    #[derive(Serialize, Debug)]
    struct MarketplaceTemplate {
        name: String,
        version: String,
        author: String,
        description: String,
        downloads: u64,
        rating: f64,
    }

    ///

    ///

    #[cfg_attr(
        feature = "otel",
        instrument(skip_all, fields(operation = "knhk.gen.marketplace.search", pattern = %pattern))
    )]
    #[verb]
    pub fn search(
        pattern: String,
        #[clap(long, default_value = "text")] format: OutputFormat,
    ) -> CnvResult<MarketplaceSearchResult> {
        gen_impl::marketplace::search_marketplace(pattern, format)
    }

    #[derive(Serialize, Debug)]
    struct MarketplaceInstallResult {
        name: String,
        version: String,
        installed_path: String,
    }

    ///

    ///

    #[cfg_attr(
        feature = "otel",
        instrument(skip_all, fields(operation = "knhk.gen.marketplace.install", name = %name))
    )]
    #[verb]
    pub fn install(
        name: String,
        #[clap(long, default_value = "text")] format: OutputFormat,
    ) -> CnvResult<MarketplaceInstallResult> {
        gen_impl::marketplace::install_from_marketplace(name, format)
    }

    #[derive(Serialize, Debug)]
    struct RatingResult {
        name: String,
        rating: f64,
        review_count: usize,
        reviews: Vec<Review>,
    }

    #[derive(Serialize, Debug)]
    struct Review {
        author: String,
        rating: f64,
        comment: String,
        date: String,
    }

    ///

    ///

    #[cfg_attr(
        feature = "otel",
        instrument(skip_all, fields(operation = "knhk.gen.marketplace.rating", name = %name))
    )]
    #[verb]
    pub fn rating(
        name: String,
        #[clap(long, default_value = "text")] format: OutputFormat,
    ) -> CnvResult<RatingResult> {
        gen_impl::marketplace::show_rating(name, format)
    }
}
