//! Overlay Proof System - Sealed Trait for Compile-Time Safety
//!
//! Proofs are first-class values that can only be constructed by trusted
//! components (compiler, validators). The type system prevents manual construction.

use crate::overlay_types::{OverlayChanges, OverlayError};
use alloc::vec::Vec;
use core::marker::PhantomData;

/// Sealed trait for overlay proofs
///
/// This trait CANNOT be implemented outside this module.
/// Only trusted proof generators can create proof values.
pub trait OverlayProof: private::Sealed + Clone {
    /// Get invariants preserved by this proof
    fn invariants_preserved(&self) -> &[u16];

    /// Get timing bound (maximum ticks)
    fn timing_bound(&self) -> u64;

    /// Verify the proof (cryptographic or logical)
    fn verify(&self) -> Result<(), OverlayError>;

    /// Check if proof covers all changes
    fn covers_changes(&self, changes: &OverlayChanges) -> bool;

    /// Get proof strength level
    fn strength(&self) -> ProofStrength;

    /// Get proof method
    fn method(&self) -> ProofMethod;
}

/// Proof strength classification
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub enum ProofStrength {
    /// Formal verification (strongest)
    Formal = 4,

    /// Compiler-generated proof
    Compiler = 3,

    /// Property-based testing
    PropertyBased = 2,

    /// Runtime verification
    Runtime = 1,
}

/// Proof method used
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ProofMethod {
    /// SMT solver (Z3, CVC5, etc.)
    Smt,

    /// Symbolic execution
    Symbolic,

    /// Abstract interpretation
    AbstractInterpretation,

    /// Type system (Rust compiler)
    TypeSystem,

    /// Property-based testing (QuickCheck, PropTest)
    PropertyTesting,

    /// Runtime monitoring
    RuntimeMonitoring,
}

/// Sealed module to prevent external trait implementation
mod private {
    pub trait Sealed {}
}

// =============================================================================
// Compiler-Generated Proofs (Strongest)
// =============================================================================

/// Compiler-generated proof
///
/// This proof is generated by the Σ→Σ* compiler during compilation.
/// It provides the strongest guarantees because it's based on static analysis.
#[derive(Debug, Clone)]
pub struct CompilerProof {
    /// Compiler version that generated this proof
    pub compiler_version: (u8, u8, u8),

    /// Proof ID (unique for this compilation)
    pub proof_id: u64,

    /// Invariants checked and preserved
    pub invariants: Vec<u16>,

    /// Timing analysis result (max ticks)
    pub timing_bound: u64,

    /// Change coverage map
    pub coverage: ChangeCoverage,

    /// Cryptographic signature over proof
    pub signature: [u8; 64],
}

impl private::Sealed for CompilerProof {}

impl OverlayProof for CompilerProof {
    fn invariants_preserved(&self) -> &[u16] {
        &self.invariants
    }

    fn timing_bound(&self) -> u64 {
        self.timing_bound
    }

    fn verify(&self) -> Result<(), OverlayError> {
        // Verify signature (simplified - would use ed25519)
        if self.signature == [0; 64] {
            return Err(OverlayError::ProofVerificationFailed);
        }

        // Verify compiler version is trusted
        if self.compiler_version < (2027, 0, 0) {
            return Err(OverlayError::ProofVerificationFailed);
        }

        Ok(())
    }

    fn covers_changes(&self, changes: &OverlayChanges) -> bool {
        // Check that all changes are covered by proof
        changes.len() <= self.coverage.covered_changes as usize
    }

    fn strength(&self) -> ProofStrength {
        ProofStrength::Compiler
    }

    fn method(&self) -> ProofMethod {
        ProofMethod::TypeSystem
    }
}

/// Change coverage information
#[derive(Debug, Clone, Copy)]
pub struct ChangeCoverage {
    /// Number of changes covered
    pub covered_changes: u32,

    /// Coverage percentage (0-100)
    pub coverage_percent: u8,
}

// =============================================================================
// Formal Verification Proofs
// =============================================================================

/// Formal verification proof (SMT solver, theorem prover)
///
/// This is the strongest possible proof, generated by formal verification tools.
#[derive(Debug, Clone)]
pub struct FormalProof {
    /// Prover used (Z3, CVC5, Lean, Coq, etc.)
    pub prover: &'static str,

    /// Proof hash (cryptographic hash of proof term)
    pub proof_hash: [u8; 32],

    /// Invariants formally verified
    pub invariants: Vec<u16>,

    /// Timing bound (proved, not estimated)
    pub timing_bound: u64,

    /// Proof certificate (can be independently verified)
    pub certificate: Vec<u8>,
}

impl private::Sealed for FormalProof {}

impl OverlayProof for FormalProof {
    fn invariants_preserved(&self) -> &[u16] {
        &self.invariants
    }

    fn timing_bound(&self) -> u64 {
        self.timing_bound
    }

    fn verify(&self) -> Result<(), OverlayError> {
        // Verify proof certificate (simplified)
        if self.certificate.is_empty() {
            return Err(OverlayError::ProofVerificationFailed);
        }

        // Verify proof hash matches certificate
        // (In reality, would check cryptographic hash)

        Ok(())
    }

    fn covers_changes(&self, _changes: &OverlayChanges) -> bool {
        // Formal proofs cover all reachable states
        true
    }

    fn strength(&self) -> ProofStrength {
        ProofStrength::Formal
    }

    fn method(&self) -> ProofMethod {
        ProofMethod::Smt
    }
}

// =============================================================================
// Property-Based Testing Proofs
// =============================================================================

/// Property-based testing proof (QuickCheck, PropTest)
///
/// Weaker than formal proof but still provides statistical guarantees.
#[derive(Debug, Clone)]
pub struct PropertyProof {
    /// Number of test cases run
    pub test_cases: u64,

    /// Shrink count (for counterexample minimization)
    pub shrink_count: u32,

    /// Invariants tested
    pub invariants: Vec<u16>,

    /// Maximum ticks observed
    pub max_ticks_observed: u64,

    /// Confidence level (0.0 - 1.0)
    pub confidence: f64,
}

impl private::Sealed for PropertyProof {}

impl OverlayProof for PropertyProof {
    fn invariants_preserved(&self) -> &[u16] {
        &self.invariants
    }

    fn timing_bound(&self) -> u64 {
        // Add margin for untested cases
        self.max_ticks_observed + 2
    }

    fn verify(&self) -> Result<(), OverlayError> {
        // Require minimum test cases
        if self.test_cases < 1000 {
            return Err(OverlayError::ProofVerificationFailed);
        }

        // Require high confidence
        if self.confidence < 0.95 {
            return Err(OverlayError::ProofVerificationFailed);
        }

        Ok(())
    }

    fn covers_changes(&self, _changes: &OverlayChanges) -> bool {
        // Property tests cover changes probabilistically
        self.confidence >= 0.95
    }

    fn strength(&self) -> ProofStrength {
        ProofStrength::PropertyBased
    }

    fn method(&self) -> ProofMethod {
        ProofMethod::PropertyTesting
    }
}

// =============================================================================
// Runtime Verification Proofs
// =============================================================================

/// Runtime verification proof (monitoring-based)
///
/// Weakest proof, based on runtime observation.
/// Only suitable for development/testing environments.
#[derive(Debug, Clone)]
pub struct RuntimeProof {
    /// Observation period (ticks)
    pub observation_period: u64,

    /// Sample count
    pub samples: u64,

    /// Invariants monitored
    pub invariants: Vec<u16>,

    /// Maximum ticks observed
    pub max_ticks_observed: u64,

    /// Violation count (should be 0)
    pub violations: u64,
}

impl private::Sealed for RuntimeProof {}

impl OverlayProof for RuntimeProof {
    fn invariants_preserved(&self) -> &[u16] {
        &self.invariants
    }

    fn timing_bound(&self) -> u64 {
        // Conservative estimate with margin
        self.max_ticks_observed + 4
    }

    fn verify(&self) -> Result<(), OverlayError> {
        // No violations allowed
        if self.violations > 0 {
            return Err(OverlayError::ProofVerificationFailed);
        }

        // Require minimum observation period
        if self.observation_period < 1_000_000 {
            return Err(OverlayError::ProofVerificationFailed);
        }

        Ok(())
    }

    fn covers_changes(&self, _changes: &OverlayChanges) -> bool {
        // Runtime proofs only cover observed behavior
        self.violations == 0 && self.samples > 1000
    }

    fn strength(&self) -> ProofStrength {
        ProofStrength::Runtime
    }

    fn method(&self) -> ProofMethod {
        ProofMethod::RuntimeMonitoring
    }
}

// =============================================================================
// Composed Proofs
// =============================================================================

/// Composition of two proofs
///
/// When overlays are composed (ΔΣ₁ ⊕ ΔΣ₂), their proofs must also compose.
/// The resulting proof strength is the minimum of the two.
#[derive(Debug, Clone)]
pub struct ComposedProof<P1: OverlayProof, P2: OverlayProof> {
    /// First proof
    pub proof1: P1,

    /// Second proof
    pub proof2: P2,

    /// Combined invariants
    pub invariants: Vec<u16>,

    /// Combined timing bound (max of both)
    pub timing_bound: u64,

    /// Type markers
    _marker: PhantomData<(P1, P2)>,
}

impl<P1: OverlayProof, P2: OverlayProof> ComposedProof<P1, P2> {
    /// Create a composed proof
    pub fn new(proof1: P1, proof2: P2) -> Result<Self, OverlayError> {
        // Verify both proofs
        proof1.verify()?;
        proof2.verify()?;

        // Combine invariants (intersection for safety)
        let inv1 = proof1.invariants_preserved();
        let inv2 = proof2.invariants_preserved();
        let invariants: Vec<_> = inv1
            .iter()
            .filter(|i1| inv2.iter().any(|i2| i1 == &i2))
            .copied()
            .collect();

        // Take maximum timing bound (conservative)
        let timing_bound = proof1.timing_bound().max(proof2.timing_bound());

        Ok(Self {
            proof1,
            proof2,
            invariants,
            timing_bound,
            _marker: PhantomData,
        })
    }
}

impl<P1: OverlayProof, P2: OverlayProof> private::Sealed for ComposedProof<P1, P2> {}

impl<P1: OverlayProof, P2: OverlayProof> OverlayProof for ComposedProof<P1, P2> {
    fn invariants_preserved(&self) -> &[u16] {
        &self.invariants
    }

    fn timing_bound(&self) -> u64 {
        self.timing_bound
    }

    fn verify(&self) -> Result<(), OverlayError> {
        self.proof1.verify()?;
        self.proof2.verify()?;
        Ok(())
    }

    fn covers_changes(&self, changes: &OverlayChanges) -> bool {
        self.proof1.covers_changes(changes) && self.proof2.covers_changes(changes)
    }

    fn strength(&self) -> ProofStrength {
        // Strength is minimum of the two (weakest link)
        use core::cmp::min;
        min(self.proof1.strength(), self.proof2.strength())
    }

    fn method(&self) -> ProofMethod {
        // Return method of stronger proof
        if self.proof1.strength() >= self.proof2.strength() {
            self.proof1.method()
        } else {
            self.proof2.method()
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_compiler_proof_verification() {
        let proof = CompilerProof {
            compiler_version: (2027, 0, 0),
            proof_id: 1,
            invariants: vec![1, 2, 3],
            timing_bound: 8,
            coverage: ChangeCoverage {
                covered_changes: 5,
                coverage_percent: 100,
            },
            signature: [1; 64],
        };

        assert!(proof.verify().is_ok());
        assert_eq!(proof.strength(), ProofStrength::Compiler);
    }

    #[test]
    fn test_formal_proof_strength() {
        let proof = FormalProof {
            prover: "Z3",
            proof_hash: [42; 32],
            invariants: vec![1, 2],
            timing_bound: 6,
            certificate: vec![1, 2, 3],
        };

        assert_eq!(proof.strength(), ProofStrength::Formal);
        assert!(proof.strength() > ProofStrength::Compiler);
    }

    #[test]
    fn test_property_proof_requires_min_tests() {
        let proof = PropertyProof {
            test_cases: 100, // Too few
            shrink_count: 0,
            invariants: vec![1],
            max_ticks_observed: 5,
            confidence: 0.99,
        };

        assert!(proof.verify().is_err());
    }

    #[test]
    fn test_runtime_proof_rejects_violations() {
        let proof = RuntimeProof {
            observation_period: 1_000_000,
            samples: 10_000,
            invariants: vec![1, 2],
            max_ticks_observed: 7,
            violations: 1, // Has violations
        };

        assert!(proof.verify().is_err());
    }
}
