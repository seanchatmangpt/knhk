// knhk-sidecar: gRPC server implementation

use std::sync::Arc;
use crate::error::{SidecarError, SidecarResult};
use crate::client::SidecarClient;
use crate::batch::BatchConfig;
use crate::tls::{TlsConfig, create_tls_server_config};
use crate::metrics::MetricsCollector;
use crate::health::HealthChecker;

/// Server configuration
#[derive(Debug, Clone)]
pub struct ServerConfig {
    /// Bind address
    pub bind_address: String,
    
    /// Batch configuration
    pub batch_config: BatchConfig,
    
    /// TLS configuration
    pub tls_config: TlsConfig,
}

impl Default for ServerConfig {
    fn default() -> Self {
        Self {
            bind_address: "127.0.0.1:50051".to_string(),
            batch_config: BatchConfig::default(),
            tls_config: TlsConfig::default(),
        }
    }
}

/// Sidecar server
pub struct SidecarServer {
    config: ServerConfig,
    client: Arc<SidecarClient>,
    metrics: Arc<MetricsCollector>,
    health: Arc<HealthChecker>,
}

impl SidecarServer {
    /// Create new sidecar server
    pub async fn new(
        server_config: ServerConfig,
        client: SidecarClient,
        metrics: Arc<MetricsCollector>,
        health: Arc<HealthChecker>,
    ) -> SidecarResult<Self> {
        Ok(Self {
            config: server_config,
            client: Arc::new(client),
            metrics,
            health,
        })
    }

    /// Start server
    pub async fn start(&self) -> SidecarResult<()> {
        let addr = self.config.bind_address.parse()
            .map_err(|e| SidecarError::ConfigError(format!("Invalid bind address: {}", e)))?;

        // Create gRPC server builder
        let mut server_builder = tonic::transport::Server::builder();

        // Configure TLS if enabled
        if self.config.tls_config.enabled {
            let tls_config = create_tls_server_config(&self.config.tls_config)?;
            server_builder = server_builder.tls_config(tls_config)
                .map_err(|e| SidecarError::TlsError(format!("Failed to configure TLS: {}", e)))?;
        }

        // Register health component
        self.health.register_component("warm_orchestrator".to_string());
        self.health.update_component(
            "warm_orchestrator",
            crate::health::HealthStatus::Healthy,
            "Connected".to_string(),
        );

        // Build and serve
        // Note: Actual service implementation will use generated proto code
        // For now, this is a placeholder structure
        
        tracing::info!("Sidecar server starting on {}", addr);
        
        // In a real implementation, we would:
        // 1. Create the service implementation
        // 2. Add it to the server builder
        // 3. Serve on the address
        
        // Placeholder: server would be started here
        // server_builder
        //     .add_service(KgcServiceServer::new(service_impl))
        //     .serve(addr)
        //     .await?;

        Ok(())
    }

    /// Handle execute transaction request
    pub async fn handle_execute_transaction(&self, rdf_delta: String) -> SidecarResult<String> {
        let _timer = LatencyTimer::start(Arc::clone(&self.metrics));
        
        // Forward to warm orchestrator
        self.client.execute_transaction(rdf_delta).await
    }

    /// Handle validate graph request
    pub async fn handle_validate_graph(&self, graph: String, schema_iri: String) -> SidecarResult<bool> {
        let _timer = LatencyTimer::start(Arc::clone(&self.metrics));
        
        self.client.validate_graph(graph, schema_iri).await
    }

    /// Handle evaluate hook request
    pub async fn handle_evaluate_hook(&self, hook_id: String, input_data: String) -> SidecarResult<String> {
        let _timer = LatencyTimer::start(Arc::clone(&self.metrics));
        
        self.client.evaluate_hook(hook_id, input_data).await
    }

    /// Handle health check request
    pub fn handle_health_check(&self, check_type: String) -> (bool, String) {
        match check_type.as_str() {
            "liveness" => self.health.check_liveness(),
            "readiness" => self.health.check_readiness(),
            _ => self.health.check_readiness(),
        }
    }

    /// Handle get metrics request
    pub fn handle_get_metrics(&self) -> crate::metrics::MetricsSnapshot {
        self.metrics.snapshot()
    }
}

/// Service implementation (placeholder - will use generated proto code)
/// This struct will implement the generated KgcService trait
pub struct KgcServiceImpl {
    server: Arc<SidecarServer>,
}

impl KgcServiceImpl {
    pub fn new(server: Arc<SidecarServer>) -> Self {
        Self { server }
    }
}

// Note: The actual service implementation methods will be generated by tonic-build
// They will look like:
// async fn execute_transaction(&self, request: Request<TransactionRequest>) -> Result<Response<TransactionResponse>, Status>
// etc.

