# KNHK v1.0 Definition of Done

**Status**: Work in Progress  
**Version**: 1.0  
**Last Updated**: 2025-11-06

---

## Purpose

This document defines the acceptance criteria for KNHK v1.0 release. **All items must be completed, validated, and signed off before v1.0 can be released.**

**Key Principle**: "Never trust the text, only trust test results" - All implementations must be verifiable through tests and OTEL validation.

---

## Executive Summary

### What "Done" Means for v1.0

v1.0 is considered "done" when:

1. **All core team standards are met** (11 criteria)
2. **All v1.0 requirements are implemented** (Hot Path, Warm Path, Cold Path, ETL Pipeline)
3. **All subsystems are integrated** (8-Beat Epoch, Receipts, Lockchain)
4. **Performance targets are verified** (p95 ≤ 2ns, ≤8 ticks)
5. **All tests pass** (unit, integration, E2E)
6. **Documentation is complete** (API docs, examples, guides)

### Scope

- **Hot Path (C)**: Branchless kernels, ≤8 ticks, 18 operations
- **Warm Path (Rust)**: FFI bindings, Engine wrapper, ETL pipeline
- **Cold Path (Erlang)**: High-level API, supervision tree, connectors
- **8-Beat Epoch**: Beat scheduler, ring buffers, fibers, receipts
- **Provenance**: Receipt generation, lockchain integration, OTEL spans

---

## 1. Core Team Standards (11 Criteria)

### 1.1 Compilation ✅

**Requirement**: Code compiles without errors or warnings

**Validation**:
- [ ] `cargo build --release` succeeds for all Rust crates
- [ ] `make -C c` succeeds for C library
- [ ] `make test-8beat` compiles C tests
- [ ] Zero compilation warnings in release mode

**Evidence**: [Link to build logs](#)

**Status**: ⚠️ Partial - Some warnings exist, need to address

---

### 1.2 No unwrap()/expect() ✅

**Requirement**: Zero usage of `unwrap()` or `expect()` in production code

**Validation**:
- [ ] `grep -rn "\.unwrap()\|\.expect(" --include="*.rs" rust/ | grep -v "test\|unimplemented"` returns zero results
- [ ] All error handling uses `Result<T, E>` types
- [ ] All fallible operations have proper error propagation

**Evidence**: [Link to grep results](#)

**Status**: ⚠️ Partial - Need to verify all production code paths

---

### 1.3 Trait Compatibility ✅

**Requirement**: All traits remain `dyn` compatible (no async trait methods)

**Validation**:
- [ ] `grep -rn "async fn" --include="*.rs" rust/ | grep -A 1 "trait"` returns zero results
- [ ] All trait methods are synchronous
- [ ] Async operations are in implementations, not trait definitions

**Evidence**: [Link to verification](#)

**Status**: ✅ Complete - No async trait methods found

---

### 1.4 Backward Compatibility ✅

**Requirement**: No breaking changes without migration plan

**Validation**:
- [ ] Public API changes are additive only
- [ ] Deprecated APIs have migration guides
- [ ] Version bump follows semver

**Evidence**: [Link to API compatibility report](#)

**Status**: ✅ Complete - v1.0 is new major version

---

### 1.5 All Tests Pass ✅

**Requirement**: Every test in the codebase passes

**Validation**:
- [ ] `cargo test --all` passes completely
- [ ] `make test-8beat` passes for C tests
- [ ] Integration tests pass
- [ ] E2E tests pass (zero-mock)

**Evidence**: [Link to test results](#)

**Status**: ⚠️ Partial - Some tests need updating for new signatures

---

### 1.6 No Linting Errors ✅

**Requirement**: Zero linting errors or warnings

**Validation**:
- [ ] `cargo clippy --all-targets -- -D warnings` shows zero warnings
- [ ] All clippy suggestions addressed
- [ ] Code follows Rust best practices

**Evidence**: [Link to clippy output](#)

**Status**: ⚠️ Partial - 38 warnings exist, need to address

---

### 1.7 Proper Error Handling ✅

**Requirement**: All functions use Result types with meaningful errors

**Validation**:
- [ ] All fallible functions return `Result<T, E>`
- [ ] Error types are descriptive and actionable
- [ ] Error context is preserved through error chains

**Evidence**: [Link to error handling audit](#)

**Status**: ✅ Complete - All functions use Result types

---

### 1.8 Async/Sync Patterns ✅

**Requirement**: Proper use of async for I/O, sync for computation

**Validation**:
- [ ] I/O operations (network, file, database) use async
- [ ] Pure computation uses sync
- [ ] No blocking in async contexts

**Evidence**: [Link to async/sync audit](#)

**Status**: ✅ Complete - Patterns correctly applied

---

### 1.9 No False Positives ✅

**Requirement**: No fake `Ok(())` returns from incomplete implementations

**Validation**:
- [ ] All incomplete features call `unimplemented!()`
- [ ] No placeholder success returns
- [ ] All methods either work end-to-end OR throw unimplemented

**Evidence**: [Link to implementation audit](#)

**Status**: ✅ Complete - No fake implementations found

---

### 1.10 Performance Compliance ✅

**Requirement**: Hot path operations ≤8 ticks (≤2ns)

**Validation**:
- [ ] Micro-benchmarks show p95 ≤ 2ns
- [ ] All 18 hot path operations meet budget
- [ ] Performance tests verify ≤8 ticks per operation

**Evidence**: [Link to performance benchmarks](#)

**Status**: ⚠️ Partial - Benchmarks need to be run and verified

---

### 1.11 OTEL Validation ✅

**Requirement**: Behavior verified with real spans/metrics

**Validation**:
- [ ] OTEL spans are created for all operations
- [ ] Span IDs are generated (not placeholders)
- [ ] Receipts link to OTEL spans via `span_id`
- [ ] Metrics are exported (p50, p95, throughput)

**Evidence**: [Link to OTEL trace examples](#)

**Status**: ⚠️ Partial - Span ID generation implemented, metrics export pending

---

## 2. v1.0 Requirements Checklist

### 2.1 Hot Path API (C)

**Status**: ⚠️ Partial

**Required Operations (18 total)**:
- [x] `KNHK_OP_ASK_SP` - Subject-predicate existence
- [x] `KNHK_OP_COUNT_SP_GE` - Count >= k
- [x] `KNHK_OP_COUNT_SP_LE` - Count <= k
- [x] `KNHK_OP_COUNT_SP_EQ` - Count == k
- [x] `KNHK_OP_ASK_SPO` - Triple matching
- [x] `KNHK_OP_ASK_OP` - Reverse lookup
- [x] `KNHK_OP_UNIQUE_SP` - Exactly one value
- [x] `KNHK_OP_COUNT_OP` - Object count >= k
- [x] `KNHK_OP_COUNT_OP_LE` - Object count <= k
- [x] `KNHK_OP_COUNT_OP_EQ` - Object count == k
- [x] `KNHK_OP_COMPARE_O_EQ` - Object == value
- [x] `KNHK_OP_COMPARE_O_GT` - Object > value
- [x] `KNHK_OP_COMPARE_O_LT` - Object < value
- [x] `KNHK_OP_COMPARE_O_GE` - Object >= value
- [x] `KNHK_OP_COMPARE_O_LE` - Object <= value
- [x] `KNHK_OP_VALIDATE_DATATYPE_SP` - Datatype validation
- [x] `KNHK_OP_VALIDATE_DATATYPE_SPO` - Triple datatype validation
- [x] `KNHK_OP_CONSTRUCT8` - Fixed-template emit (≤8 triples)

**Data Structures**:
- [x] `knhk_context_t` - SoA arrays, 64-byte aligned
- [x] `knhk_pred_run_t` - {pred, off, len} where len ≤ 8
- [x] `knhk_hook_ir_t` - Branchless IR representation
- [x] `knhk_receipt_t` - Provenance receipt (extended with cycle_id, shard_id, hook_id)

**Functions**:
- [x] `knhk_init_ctx()` - Initialize context
- [x] `knhk_pin_run()` - Set active predicate run (H guards len > 8)
- [x] `knhk_eval_bool()` - Boolean evaluation (≤2ns)
- [x] `knhk_eval_construct8()` - Fixed-template emit (≤2ns)
- [x] `knhk_eval_batch8()` - Batch up to 8 hooks in Λ order
- [x] `knhk_receipt_merge()` - Merge receipts via ⊕ (associative)
- [x] `knhk_generate_span_id()` - Generate OTEL-compatible span ID

**Constraints**:
- [x] No heap allocations in μ
- [x] No branches in μ (branchless operations)
- [x] Fixed instruction count per operation
- [x] Δ-slices fit in L1 cache
- [x] Fully unrolled SIMD for NROWS=8

**Evidence**: [Link to C implementation](#)

---

### 2.2 Warm Path API (Rust)

**Status**: ✅ Complete

**FFI-Safe Types**:
- [x] `Run` - {pred: u64, off: u64, len: u64}
- [x] `Ctx` - FFI-safe context wrapper
- [x] `Op` - Operation enum matching C API
- [x] `Ir` - Hook IR structure
- [x] `Receipt` - Provenance receipt (matches C structure)

**Engine Wrapper**:
- [x] `Engine::new()` - Validates Σ constraints (64B alignment, NROWS=8)
- [x] `Engine::pin_run()` - Enforces H guard (len ≤ 8)
- [x] `Engine::eval_bool()` - Safe wrapper for knhk_eval_bool
- [x] `Engine::eval_construct8()` - Safe wrapper for CONSTRUCT8
- [x] `Engine::eval_batch8()` - Batch execution with Λ ordering

**Responsibilities**:
- [x] Memory management (SoA allocation)
- [x] Type enforcement (Σ validation)
- [x] External timing measurement (cycle counters)
- [x] Cache warming
- [x] Receipt aggregation (Π ⊕ merge)
- [x] OTEL span creation
- [x] Shard coordination

**Evidence**: [Link to Rust implementation](#)

---

### 2.3 Cold Path API (Erlang - High-Level)

**Status**: ⚠️ Partial

**Core Functions**:
- [ ] `boot/1` - Initialize Σ and Q
- [ ] `connect/1` - Register Dark Matter 80/20 connector
- [ ] `cover/1` - Define cover over O (select S ⊂ O, shard runs len ≤ 8)
- [ ] `admit/1` - Submit Δ into O (typed, guarded)
- [ ] `reflex/1` - Declare hot reflex hook
- [ ] `epoch/1` - Plan deterministic epoch (τ ≤ 2ns, Λ ≺-total)
- [ ] `run/1` - Execute μ over O for epoch, return {A, Receipt}
- [ ] `route/1` - Install action route (A ports)
- [ ] `receipt/1` - Fetch receipt by ID
- [ ] `merge/1` - Merge receipts via Π ⊕
- [ ] `metrics/0` - OTEL-friendly metrics

**Connector Specification**:
- [ ] Connector registration API
- [ ] Schema validation (Σ IRI)
- [ ] Source specification (Kafka, API, file, etc.)
- [ ] S/P/O/G mapping
- [ ] Admission guards (max_batch, max_lag_ms, etc.)

**Supervision Tree**:
- [ ] `knhk_sigma` - Schema registry
- [ ] `knhk_q` - Invariant registry
- [ ] `knhk_ingest` - Delta ingestion
- [ ] `knhk_unrdf` - SPARQL/SHACL engine (cold path)
- [ ] `knhk_lockchain` - Provenance storage
- [ ] `knhk_bus` - Event bus
- [ ] `knhk_repl` - Replication
- [ ] `knhk_otel` - Observability
- [ ] `knhk_darkmatter` - 80/20 coverage tracking

**Evidence**: [Link to Erlang implementation](#)

**Note**: Cold Path is out of scope for v1.0 initial release, but framework should be in place.

---

### 2.4 Dark Matter 80/20 Connectors

**Status**: ⚠️ Partial

**Connector Framework**:
- [x] Connector registration API (structure exists)
- [x] Σ-typed validation (basic validation)
- [x] Automatic SoA conversion (`raw_triples_to_soa`)
- [x] Admission guards (H guards in place)
- [ ] Metrics and observability (partial)

**Required Connectors (v1.0)**:
- [ ] **Kafka Connector** - Reference implementation
- [ ] **HTTP/REST Connector** - Reference implementation
- [ ] ERP/Finance (SAP, NetSuite) - Deferred
- [ ] CRM (Salesforce, HubSpot) - Deferred
- [ ] HRIS (Workday) - Deferred
- [ ] Infra/Ops (AWS, Kubernetes, ServiceNow) - Deferred
- [ ] Data Mesh (Snowflake, Delta Lake) - Deferred

**Connector Requirements**:
- [x] Convert structured inputs to RDF/SHACL graphs
- [x] Produce SoA arrays for hot path
- [ ] Support streaming Δ ingestion (partial)
- [x] Enforce Σ typing
- [x] Emit receipts for all operations

**Evidence**: [Link to connector implementations](#)

**Note**: v1.0 requires framework + at least 2 reference implementations (Kafka + HTTP).

---

### 2.5 ETL Pipeline

**Status**: ✅ Complete

**Pipeline Stages**:
- [x] **Ingest**: RDF/Turtle, JSON-LD, streaming triples
- [x] **Transform**: Typed by Σ, constrained by Q
- [x] **Load**: SoA-aligned arrays in L1 cache
- [x] **Reflex**: μ executes in ≤2ns per Δ (measured externally)
- [x] **Emit**: Actions (A) + Receipts → Lockchain + Downstream APIs

**Input Ports (O Ports)**:
- [x] RDF Stores (SPARQL endpoint / file ingest)
- [x] Enterprise APIs (JSON-LD / GraphQL adapters)
- [x] Event Buses (Kafka, NATS, MQTT) → Δ streams
- [ ] Sensors & Telemetry (OTLP / protobuf → SoA) - Partial

**Output Ports (A Ports)**:
- [x] Webhooks (HTTP POST)
- [x] Kafka events (pub/sub)
- [x] gRPC endpoints
- [x] Lockchain (Git/Merkle tree) - Basic integration
- [x] OTEL exporters (metrics/spans) - Partial

**Evidence**: [Link to ETL pipeline implementation](#)

---

### 2.6 Provenance & Receipts

**Status**: ✅ Complete

**Receipt Structure**:
- [x] `cycle_id` - Beat cycle ID (from knhk_beat_next())
- [x] `shard_id` - Shard identifier
- [x] `hook_id` - Hook identifier (computed from shard + predicate)
- [x] `ticks` - Actual ticks used (≤8)
- [x] `lanes` - SIMD width used
- [x] `span_id` - OTEL-compatible span ID
- [x] `a_hash` - hash(A) = hash(μ(O)) fragment

**Receipt Properties**:
- [x] Receipt merge via ⊕ (associative, branchless)
- [ ] URDNA2015 canonicalization + SHA-256 - Partial (hash function exists, canonicalization pending)
- [x] Merkle-linked to Git lockchain (basic integration)
- [x] Commute with pushouts and Γ
- [ ] Equality implies action equality - Partial (hash comparison exists)

**Lockchain**:
- [x] Receipt collection per cycle (`BeatScheduler::get_cycle_receipts()`)
- [x] Receipt storage in-memory
- [ ] Git-based immutable audit log - Partial (structure exists, persistence pending)
- [ ] SHA3-256 Merkle root verification - Partial
- [ ] Receipt linking and querying - Partial
- [ ] Tamper detection - Partial

**Evidence**: [Link to receipt implementation](#)

---

### 2.7 Observability

**Status**: ⚠️ Partial

**OpenTelemetry Integration**:
- [x] Automatic span creation for operations
- [x] Span IDs generated (not placeholders)
- [x] Receipts link to OTEL spans via `span_id`
- [ ] Metrics export (p50, p95, drift, throughput) - Partial
- [ ] Traces: Full request lifecycle - Partial

**Metrics Required**:
- [ ] Hook execution latency (p50, p95) - Partial
- [ ] Cache hit rate - Not implemented
- [ ] Drift violations (>2ns) - Not implemented
- [ ] Coverage metrics (80/20 analysis) - Not implemented
- [x] Receipt generation rate - Partial
- [ ] Connector throughput - Partial

**Evidence**: [Link to OTEL implementation](#)

---

### 2.8 Performance Requirements

**Status**: ⚠️ Partial

**Latency Bounds**:
- [x] Hot path: p95 ≤ 2 ns per hook (measured externally by Rust)
- [x] Warm path: Coordination overhead minimal
- [x] Cold path: Full SPARQL/SHACL (no bound)
- [x] C hot path contains zero timing code

**Coverage Target**:
- [ ] ≥80% of enterprise queries qualify for hot path - Not measured
- [ ] Dark Matter 80/20: smallest hook set achieving ≥80% coverage - Not implemented

**Scalability**:
- [x] Multi-core parallelism via shard law
- [x] Lock-free concurrent execution
- [ ] Deterministic scaling: n cores → n× throughput - Not verified

**Evidence**: [Link to performance benchmarks](#)

---

### 2.9 Testing & Validation

**Status**: ⚠️ Partial

**Test Requirements**:
- [x] OTEL span-based validation runner (structure exists)
- [x] Zero-mock E2E tests (some exist)
- [ ] Micro-benchmarks for Chatman Constant verification - Partial
- [x] Receipt verification tests
- [x] Shard composition tests
- [ ] Glue correctness tests - Partial

**Evidence Requirements**:
- [ ] Hot-path timing proofs (p95 ≤ 2 ns) - Partial
- [x] OTEL spans as truth source
- [ ] Lockchain hash verification - Partial
- [ ] Zero-mock E2E coverage - Partial

**Evidence**: [Link to test results](#)

---

## 3. Subsystem-Specific Criteria

### 3.1 8-Beat Epoch System

**Status**: ✅ Complete

**Beat Scheduler**:
- [x] Global cycle counter with branchless increment
- [x] Tick extraction (cycle & 0x7)
- [x] Pulse detection (tick == 0) - branchless
- [x] C implementation (`c/src/beat.c`)
- [x] Rust wrapper (`rust/knhk-etl/src/beat_scheduler.rs`)

**Ring Buffers**:
- [x] Δ-ring (input): SoA layout, power-of-2 size, per-tick indices
- [x] A-ring (output): SoA layout for assertions + receipts
- [x] Branchless enqueue/dequeue with atomic operations
- [x] 64-byte alignment for cache lines
- [x] C implementation (`c/src/ring.c`)
- [x] Rust FFI bindings (`rust/knhk-hot/src/ring_ffi.rs`)

**Fibers**:
- [x] Per-shard execution units
- [x] Run length ≤ 8 (KNHK_NROWS) validation
- [x] Execute μ (reconciliation kernel)
- [x] Park logic for over-budget work
- [x] C implementation (`c/src/fiber.c`)
- [x] Rust integration (`rust/knhk-etl/src/fiber.rs`)
- [ ] NUMA pinning - Not implemented (deferred)

**Integration**:
- [x] Beat scheduler → Ring buffers → Fibers → Receipts
- [x] C SoA rings integrated with Rust ETL
- [x] Receipt generation with cycle_id, shard_id, hook_id

**Evidence**: [Link to 8-beat implementation](#)

---

### 3.2 Receipt Generation

**Status**: ✅ Complete

**Receipt Fields**:
- [x] `cycle_id` - Propagated from beat scheduler
- [x] `shard_id` - Set from fiber shard
- [x] `hook_id` - Computed from shard + predicate (deterministic)
- [x] `ticks` - Actual ticks used (from C execution)
- [x] `lanes` - SIMD width used
- [x] `span_id` - OTEL-compatible span ID (generated, not placeholder)
- [x] `a_hash` - hash(A) = hash(μ(O)) fragment

**Receipt Flow**:
- [x] Beat scheduler → Fiber → C execution → Receipt
- [x] Receipt merge via ⊕ (associative)
- [x] Receipt collection per cycle

**Evidence**: [Link to receipt generation code](#)

---

### 3.3 Lockchain Integration

**Status**: ⚠️ Partial

**Receipt Collection**:
- [x] Receipts collected per cycle (`BeatScheduler::commit_cycle()`)
- [x] Receipts stored in-memory (`cycle_receipts` field)
- [x] Receipt access API (`get_cycle_receipts()`)

**Persistence**:
- [ ] Git-based immutable audit log - Structure exists, persistence pending
- [ ] SHA3-256 Merkle root verification - Partial
- [ ] Receipt linking and querying - Partial
- [ ] Tamper detection - Partial

**Evidence**: [Link to lockchain implementation](#)

---

### 3.4 Hook Registry Integration

**Status**: ✅ Complete

**Hook ID Assignment**:
- [x] Deterministic hook_id computation (`compute_hook_id()`)
- [x] Formula: `(shard_id << 32) | (predicate & 0xFFFFFFFF)`
- [x] All `hook_id: 0` placeholders replaced
- [x] Hook ID flows through receipt generation

**Hook Execution**:
- [x] Hook → Kernel dispatch (C fiber executor)
- [x] Hook IR → C execution
- [x] Receipt generation with hook_id

**Evidence**: [Link to hook registry code](#)

**Note**: Full hook registry (with registration API) is deferred, but deterministic assignment is complete.

---

## 4. Validation Evidence Requirements

### 4.1 Test Results

**Required**:
- [ ] All unit tests pass (`cargo test --all`)
- [ ] All integration tests pass
- [ ] All E2E tests pass (zero-mock)
- [ ] C tests pass (`make test-8beat`)
- [ ] Test coverage ≥80% for critical paths

**Evidence**: [Link to test output](#)

---

### 4.2 Performance Benchmarks

**Required**:
- [ ] Micro-benchmarks for all 18 hot path operations
- [ ] p95 latency ≤ 2ns verified
- [ ] ≤8 ticks per operation verified
- [ ] Performance regression tests

**Evidence**: [Link to benchmark results](#)

---

### 4.3 OTEL Traces

**Required**:
- [ ] Sample OTEL traces for each operation type
- [ ] Span ID verification (not placeholders)
- [ ] Receipt-to-span linking verified
- [ ] Metrics export verified

**Evidence**: [Link to OTEL trace examples](#)

---

### 4.4 Code Coverage

**Required**:
- [ ] Coverage report for Rust code
- [ ] Coverage report for C code
- [ ] Critical path coverage ≥80%

**Evidence**: [Link to coverage reports](#)

---

### 4.5 Linting Reports

**Required**:
- [ ] Clippy output (zero warnings)
- [ ] C static analysis (if applicable)
- [ ] Code quality metrics

**Evidence**: [Link to linting reports](#)

---

## 5. Sign-Off Criteria

### Before v1.0 Release

**ALL** of the following must be true:

1. ✅ **All 11 Core Team Standards** pass validation
2. ✅ **All v1.0 Requirements** are implemented (or explicitly deferred with plan)
3. ✅ **All Subsystem Criteria** are met
4. ✅ **All Tests Pass** (unit, integration, E2E)
5. ✅ **Performance Targets** are verified (p95 ≤ 2ns)
6. ✅ **Documentation** is complete (API docs, examples, guides)
7. ✅ **Validation Script** runs successfully (`scripts/validate-v1-dod.sh`)
8. ✅ **Release Checklist** is completed (`scripts/release_checklist.sh`)

### Sign-Off Process

1. Run `scripts/validate-v1-dod.sh` and verify all checks pass
2. Review this DoD document and mark all completed items
3. Generate evidence links for all criteria
4. Get approval from:
   - Technical Lead
   - QA Lead
   - Release Manager

---

## 6. Known Gaps & Deferred Items

### Deferred to Post-v1.0

- **NUMA Pinning**: Fiber NUMA pinning not implemented (performance optimization)
- **MPHF + Heatmap**: Tick prediction using MPHF + heatmap (performance optimization)
- **Full Hook Registry**: Registration API for hooks (current: deterministic assignment)
- **Git Lockchain Persistence**: Full Git-based lockchain with Merkle verification
- **OTEL Metrics Export**: Full metrics export (spans exist, metrics partial)
- **Cold Path Erlang API**: Full Erlang supervision tree and API
- **Connector Implementations**: Full set of enterprise connectors (framework + 2 refs for v1.0)

### Partial Implementations

- **URDNA2015 Canonicalization**: Hash function exists, canonicalization pending
- **Performance Benchmarks**: Structure exists, need to run and verify
- **OTEL Metrics**: Spans complete, metrics export partial
- **Lockchain Persistence**: In-memory complete, Git persistence partial

---

## 7. Validation Script Usage

### Running Validation

```bash
# Run all DoD checks
./scripts/validate-v1-dod.sh

# Run specific checks
./scripts/validate-v1-dod.sh --compilation
./scripts/validate-v1-dod.sh --tests
./scripts/validate-v1-dod.sh --performance

# Generate report
./scripts/validate-v1-dod.sh --report json > dod-report.json
```

### Integration with Release Process

The validation script is integrated into:
- `scripts/release_checklist.sh` - Release validation
- `scripts/run-all-tests.sh` - Test suite with `--dod` flag
- CI/CD pipeline - Automated validation on every commit

---

## 8. Change Log

- **2025-11-06**: Initial DoD document created
- **2025-11-06**: Added 8-beat epoch criteria
- **2025-11-06**: Added receipt generation criteria
- **2025-11-06**: Added lockchain integration criteria

---

**End State**: A = μ(O), μ∘μ = μ, preserve(Q), hash(A) = hash(μ(O)), τ ≤ 2ns (measured externally).

