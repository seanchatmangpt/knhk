{
    "sourceFile": "docs/hooks-engine-2ns-use-cases.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1762387738218,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1762387738218,
            "name": "Commit-0",
            "content": "# Hooks Engine: 2ns Guard Enforcement\n\n## Purpose: Why Hooks Exist\n\nThe hooks engine implements the **Guard** law: `μ ⊣ H` (partial). Hooks are the mechanism by which the system enforces invariants `Q` over operations `O` before canonicalization `μ` produces artifacts `A`.\n\n**Why 2ns matters**: The hot path constraint requires guard evaluation within 2 nanoseconds (8 ticks). Hooks operating outside this constraint belong to the cold path, where full SPARQL evaluation and complex validation occur.\n\n## Architecture: Two-Tier Hook System\n\n### Use Case 1: Single Hook Execution (2ns Target)\n\n**Function**: `evaluate_hook_native(hook: H, turtle_data: O) -> HookResult`\n\n**Law**: `Guard: μ ⊣ H` where `H` is a partial function checking `O ⊨ Σ` before `A = μ(O)`.\n\n**What it does**:\n1. Extract SPARQL ASK query from hook definition `H`\n2. Load operations `O` into `NativeStore`\n3. Execute `ASK { condition }` query\n4. If condition holds: generate receipt `hash(A) = hash(μ(O))`\n5. Return `HookResult { fired: bool, result: Option<A>, receipt: Option<hash> }`\n\n**Why single hook execution**:\n- Hot path operations require guard checks before merging\n- Must verify `O ⊨ Σ` (typing) before `A = μ(O)` (canonicalization)\n- Receipt generation ensures provenance: `hash(A) = hash(μ(O))`\n\n**2ns constraint**:\n- Simple ASK queries: `ASK { ?s ?p ?o }` → evaluates in <2ns\n- Complex queries: move to cold path (batch evaluation)\n- Memory layout: zero-copy where possible, SIMD-aware structures\n\n### Use Case 2: Batch Hook Evaluation (Cold Path)\n\n**Function**: `evaluate_hooks_batch_native(hooks: Vec<H>, turtle_data: O) -> Vec<HookResult>`\n\n**Law**: `Invariant: preserve(Q)` where `Q` is the set of invariants enforced by hooks.\n\n**What it does**:\n1. Accept multiple hooks `H₁, H₂, ..., Hₙ`\n2. Execute hooks in parallel using Rayon\n3. Collect results: `Vec<HookResult>`\n4. Preserve order: `Λ` is `≺`-total (results maintain hook order)\n\n**Why batch evaluation**:\n- Cold path operations can afford >2ns latency\n- Parallel execution: `Π` is `⊕`-monoid (merge operations are associative)\n- Efficient validation: check all invariants `Q` before `A = μ(O)`\n\n**Performance**:\n- Parallel execution scales with CPU cores\n- Each hook gets independent `NativeStore` instance (no shared mutable state)\n- Receipt generation: `hash(A) = hash(μ(O))` for each fired hook\n\n## Mathematical Foundation\n\n### Guard Function: `μ ⊣ H`\n\n**Definition**: `H` is a partial function that validates `O ⊨ Σ` before `A = μ(O)`.\n\n**Properties**:\n- **Idempotence**: `μ ∘ μ = μ` (canonicalization is idempotent)\n- **Typing**: `O ⊨ Σ` (operations satisfy schema)\n- **Guard**: `μ ⊣ H` (canonicalization left-adjoint to guard)\n\n**Hook execution**:\n```\nO (operations) → H (hook guard) → {pass, fail}\n  ↓ (if pass)\nμ(O) → A (artifacts)\n  ↓\nhash(A) = hash(μ(O)) (provenance receipt)\n```\n\n### Invariant Preservation: `preserve(Q)`\n\n**Definition**: Hooks enforce invariants `Q` over operations `O`.\n\n**Law**: `Invariant: preserve(Q)` where `Q` is the set of schema constraints, ordering constraints, and merge constraints.\n\n**Example invariants**:\n- `O ⊨ Σ` (typing: triples conform to schema)\n- `Λ` is `≺`-total (ordering: no cycles)\n- `Π` is `⊕`-monoid (merge: associative operations)\n\n### Provenance: `hash(A) = hash(μ(O))`\n\n**Definition**: Receipt generation ensures cryptographic provenance.\n\n**Properties**:\n- Receipt format: `hash(hook_id + canonical_data_hash + timestamp + counter)`\n- Uniqueness: nanosecond timestamp + atomic counter\n- Deterministic: same `O` → same `hash(μ(O))`\n\n**Why receipts matter**:\n- **Shard**: `μ(O ⊔ Δ) = μ(O) ⊔ μ(Δ)` (sharding preserves provenance)\n- **Provenance**: `hash(A) = hash(μ(O))` (artifact hash equals canonicalized operation hash)\n- **Van Kampen**: `pushouts(O) ↔ pushouts(A)` (pushouts preserve hashes)\n\n## Epoch Constraints: `μ ⊂ τ`\n\n**Definition**: Hook execution occurs within epoch boundaries `τ`.\n\n**Properties**:\n- Epoch: `μ ⊂ τ` (canonicalization within epoch)\n- Order: `Λ` is `≺`-total (epoch ordering is total)\n- Sparsity: `μ → S` (80/20 principle: focus on critical 20% of hooks)\n\n**Why epochs matter**:\n- Hooks fire at epoch boundaries\n- Batch evaluation groups hooks by epoch\n- Receipts include epoch timestamp\n\n## Sparsity: `μ → S` (80/20)\n\n**Definition**: Hook system focuses on critical 20% of invariants.\n\n**Properties**:\n- **Sparsity**: `μ → S` (canonicalization maps to sparse set)\n- **Minimality**: `argmin drift(A)` (minimize drift from canonical state)\n\n**Why sparsity**:\n- Not all hooks need hot path execution\n- Simple ASK queries: hot path (2ns)\n- Complex queries: cold path (batch evaluation)\n- Focus on critical invariants: typing, ordering, merge constraints\n\n## Hook Registry: `NativeHookRegistry`\n\n**Function**: Thread-safe registry for hook definitions `H`.\n\n**Operations**:\n- `register(hook: H)`: Add hook to registry\n- `deregister(hook_id: String)`: Remove hook from registry\n- `list() -> Vec<H>`: List all registered hooks\n- `get(hook_id: String) -> Option<H>`: Retrieve hook by ID\n\n**Why registry**:\n- Manages hook definitions `H`\n- Thread-safe: `Arc<Mutex<HashMap<String, H>>>`\n- Enables dynamic hook registration/deregistration\n\n**Constraints**:\n- **Constitution**: `∧(Typing,ProjEq,FixedPoint,Order,Merge,Sheaf,VK,Shard,Prov,Guard,Epoch,Sparse,Min,Inv)`\n- All hooks must satisfy constitution constraints\n- Registry validates hook definitions before registration\n\n## Hook Definition Structure\n\n**Hook Definition**: `H = { id, name, hook_type, definition }`\n\n**Definition Structure**:\n```json\n{\n  \"when\": {\n    \"kind\": \"sparql-ask\",\n    \"query\": \"ASK { ?s ?p ?o }\"\n  }\n}\n```\n\n**Why SPARQL ASK**:\n- ASK queries return boolean (pass/fail)\n- Efficient evaluation (no result binding)\n- Matches guard function: `H(O) -> {true, false}`\n\n**Query Types**:\n- Hot path: Simple ASK queries (<2ns)\n- Cold path: Complex queries with filters, joins, etc.\n\n## Execution Flow\n\n### Single Hook Execution (Use Case 1)\n\n```\n1. Extract hook query: H.when.query\n2. Load O into NativeStore: store.load_turtle(O)\n3. Execute ASK query: store.query(ASK { condition })\n4. If fired:\n   a. Generate receipt: hash(hook_id + canonical_hash(O) + timestamp + counter)\n   b. Return HookResult { fired: true, result: Some(A), receipt: Some(hash) }\n5. Else: return HookResult { fired: false, result: None, receipt: None }\n```\n\n### Batch Hook Evaluation (Use Case 2)\n\n```\n1. For each hook H_i in Vec<H>:\n   a. Create independent NativeStore instance\n   b. Load O into store\n   c. Execute ASK query\n   d. Generate receipt if fired\n2. Collect results: Vec<HookResult>\n3. Return batch results maintaining order Λ\n```\n\n## Performance Characteristics\n\n### Hot Path (2ns Target)\n\n**Constraints**:\n- Single hook execution: <2ns for simple ASK queries\n- Memory layout: zero-copy, SIMD-aware\n- Branchless operations: constant-time execution\n- No allocations: stack-only operations\n\n**Achievable**:\n- Simple ASK: `ASK { ?s ?p ?o }` → <1ms (cold path)\n- Hot path requires specialized SPARQL engine (future work)\n\n### Cold Path (Batch Evaluation)\n\n**Constraints**:\n- Batch evaluation: parallel execution via Rayon\n- Each hook: independent store instance\n- Scalability: linear with CPU cores\n- Memory: efficient allocation patterns\n\n**Achievable**:\n- 100 hooks: <100ms (parallel)\n- 1000 hooks: <1s (parallel)\n- Throughput: 1000+ hooks/sec\n\n## Why Hooks Exist: Summary\n\n1. **Guard Enforcement**: `μ ⊣ H` (partial) - validate `O ⊨ Σ` before `A = μ(O)`\n2. **Invariant Preservation**: `preserve(Q)` - enforce schema, ordering, merge constraints\n3. **Provenance**: `hash(A) = hash(μ(O))` - cryptographic receipts for traceability\n4. **Epoch Boundaries**: `μ ⊂ τ` - hooks fire at epoch transitions\n5. **Sparsity**: `μ → S` (80/20) - focus on critical 20% of invariants\n\n**What hooks are NOT**:\n- Not \"semantic\" checks (no meaning)\n- Not \"self-\" systems (no autonomous control)\n- Not human-defined (KGC and LLMs generate hooks)\n- Not deterministic by default (humans add noise)\n\n**What hooks ARE**:\n- Measurable guard functions `H(O) -> bool`\n- Ontology-based (schema `Σ` validation)\n- System-generated (KGC/LLM managed)\n- Deterministic when possible (no human noise)\n\n## Implementation Notes\n\n### Thread Safety\n- `NativeHookRegistry`: `Arc<Mutex<HashMap<String, H>>>`\n- Receipt generation: atomic counter for uniqueness\n- Parallel execution: Rayon thread pool\n\n### Error Handling\n- Invalid hooks: return `UnrdfError::HookFailed`\n- Query type mismatch: validate ASK queries only\n- Data loading errors: propagate with context\n\n### Memory Management\n- Zero-copy where possible: `&str` over `String`\n- Efficient allocation: reuse store instances\n- RAII: automatic cleanup on drop\n\n### Observability\n- Receipt generation: cryptographic hashing\n- Execution metrics: throughput, latency\n- Error tracking: detailed error messages\n\n## Conclusion\n\nThe hooks engine implements the **Guard** law `μ ⊣ H` (partial), enforcing invariants `Q` over operations `O` before canonicalization `μ` produces artifacts `A`. The two-tier system (single hook <2ns, batch evaluation >2ns) balances performance with correctness, ensuring `O ⊨ Σ` (typing) and `preserve(Q)` (invariant preservation) while maintaining cryptographic provenance through `hash(A) = hash(μ(O))`.\n\n**Key Laws**:\n- `Guard: μ ⊣ H` (partial)\n- `Invariant: preserve(Q)`\n- `Provenance: hash(A) = hash(μ(O))`\n- `Epoch: μ ⊂ τ`\n- `Sparsity: μ → S` (80/20)\n\n**Never use**: \"semantic\", \"self-\" prefixes\n**Always use**: Measurable terms (ontology, schema, invariants, guards)\n\n"
        }
    ]
}