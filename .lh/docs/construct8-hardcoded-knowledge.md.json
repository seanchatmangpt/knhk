{
    "sourceFile": "docs/construct8-hardcoded-knowledge.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1762376291496,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1762376291496,
            "name": "Commit-0",
            "content": "# Hardcoded Knowledge Construction: 80/20 Enterprise CONSTRUCT Use Cases\n\n## Overview\nAnalysis of what knowledge can be **hardcoded/precomputed** at Rust warm/cold path time vs what must be computed at C hot path runtime. Focus on 80/20 enterprise patterns that provide maximum value.\n\n## Key Insight: Hardcoded Knowledge = Zero Hot Path Cost\n\n**Principle**: If Rust can precompute it at warm/cold path time, it costs **0 ticks** in the hot path.\n\n## 1. Hardcoded Knowledge Patterns (100% Precomputable)\n\n### 1.1. Fixed Template Constants\n**Current Runtime Cost:** Broadcast `p_const` and `o_const` (~1 tick)\n\n**Hardcoded Knowledge:**\n- **Authorization**: `(?u, ex:hasAccess, ?r)` template\n  - `p_const = ex:hasAccess` (fixed predicate)\n  - `o_const = ex:Allowed` or `ex:Denied` (constant based on policy)\n  - **Rust can precompute**: Broadcast vectors, store as constants\n\n- **Compliance Classification**: `(?s, rdf:type, :Compliant)` template\n  - `p_const = rdf:type` (fixed predicate)\n  - `o_const = :Compliant` (constant classification)\n  - **Rust can precompute**: All constants\n\n- **Risk Flags**: `(?asset, ex:riskLevel, ?level)` template\n  - `p_const = ex:riskLevel` (fixed predicate)\n  - `o_const = ex:High|Medium|Low` (precomputed from policy)\n  - **Rust can precompute**: Classification constants\n\n**Savings:** ~1 tick (eliminates runtime broadcasts)\n\n### 1.2. Length-Based Specialization\n**Current Runtime Cost:** `len_mask_bits = ((1ULL << len) - 1) & 0xFFULL` (~0.25 ticks)\n\n**Hardcoded Knowledge:**\n- Most enterprise runs have predictable `len` values:\n  - Authorization: typically `len = 1-4` (user has 1-4 permissions)\n  - Compliance: typically `len = 1-8` (resource has 1-8 compliance flags)\n  - Provenance: typically `len = 8` (full batch)\n\n**Rust can generate:**\n- Specialized functions for each `len` value: `knhk_construct8_emit_8_len1()` through `knhk_construct8_emit_8_len8()`\n- Each function has `len_mask_bits` as compile-time constant: `0x01`, `0x03`, `0x07`, `0x0F`, `0x1F`, `0x3F`, `0x7F`, `0xFF`\n\n**Savings:** ~0.25 ticks per call\n\n### 1.3. Pattern-Based Precomputation\n**Current Runtime Cost:** Mask generation (~4 ticks)\n\n**Hardcoded Knowledge:**\n- **All-NonZero Pattern**: Enterprise data often has no zeros\n  - Authorization: Users always have at least one permission\n  - Compliance: Resources always have compliance state\n  - **Rust can detect**: Precompute mask = `0xFF` (all non-zero)\n  - **Hot path**: Skip mask generation entirely\n\n- **All-Zero Pattern**: Empty runs (rare but detectable)\n  - **Rust can detect**: Early return (0 ticks)\n  - **Hot path**: Skip everything\n\n- **Sparse Pattern**: Known zero positions\n  - **Rust can detect**: Precompute zero-position hint bitmask\n  - **Hot path**: Use hint to skip unnecessary comparisons\n\n**Savings:** ~4 ticks for all-nonzero pattern\n\n### 1.4. Provenance Templates\n**Current Runtime Cost:** Receipt generation (moved out of hot path)\n\n**Hardcoded Knowledge:**\n- Provenance receipt structure is fixed template:\n  - `(?action, ex:hasReceipt, ?receipt)`\n  - `(?receipt, ex:spanId, ?spanId)`\n  - `(?receipt, ex:aHash, ?hash)`\n  - **Rust can precompute**: Receipt template structure\n  - **Hot path**: Just fill in values (no structure computation)\n\n**Savings:** Receipt generation already moved out of hot path\n\n## 2. 80/20 Enterprise CONSTRUCT Use Cases\n\nBased on enterprise test data and CONVO.txt analysis, here are the most common patterns:\n\n### 2.1. Authorization Reflex (30% of Runtime) - TOP PRIORITY\n\n**Pattern:**\n```sparql\nCONSTRUCT { ?u ex:hasAccess ?r } WHERE { ?u ex:role ?x . ?x ex:grants ?r }\n```\n\n**Hardcoded Knowledge:**\n- Template: `(?u, ex:hasAccess, ?r)`\n- `p_const = ex:hasAccess` (fixed)\n- `o_const = ?r` (from role grants - can be precomputed at warm path)\n- Length: Typically 1-4 permissions per user\n\n**Rust AOT Preparation:**\n1. Precompute role→permission mappings at warm path\n2. Generate specialized function: `knhk_construct8_emit_8_auth()`\n3. Precompute broadcast vectors for common permission sets\n4. Store authorization template in IR structure\n\n**Hot Path Cost:** ~6 ticks (with optimizations)\n\n**Use Cases:**\n- RBAC permission checks\n- Entitlement generation\n- Access control decisions\n\n### 2.2. Compliance Classification (20% of Runtime)\n\n**Pattern:**\n```sparql\nCONSTRUCT { ?s rdf:type :Compliant } WHERE { ?s ex:passesPolicy true }\n```\n\n**Hardcoded Knowledge:**\n- Template: `(?s, rdf:type, :Compliant)`\n- `p_const = rdf:type` (fixed)\n- `o_const = :Compliant` (constant)\n- Pattern: All subjects that pass policy → all non-zero\n\n**Rust AOT Preparation:**\n1. Precompute compliance state from policy evaluation\n2. Generate specialized function: `knhk_construct8_emit_8_compliant()`\n3. Use all-nonzero pattern specialization (skip mask generation)\n4. Precompute broadcast vectors\n\n**Hot Path Cost:** ~4 ticks (with all-nonzero optimization)\n\n**Use Cases:**\n- Regulatory compliance flags\n- Policy compliance states\n- Audit trail generation\n\n### 2.3. Risk Flag Generation (15% of Runtime)\n\n**Pattern:**\n```sparql\nCONSTRUCT { ?asset ex:riskLevel ?level } WHERE { ?asset ex:riskScore ?score . FILTER(?score > threshold) }\n```\n\n**Hardcoded Knowledge:**\n- Template: `(?asset, ex:riskLevel, ?level)`\n- `p_const = ex:riskLevel` (fixed)\n- `o_const = ex:High|Medium|Low` (precomputed from thresholds)\n- Pattern: Risk levels computed from scores (can be precomputed)\n\n**Rust AOT Preparation:**\n1. Precompute risk levels from scores at warm path\n2. Generate specialized function: `knhk_construct8_emit_8_risk()`\n3. Precompute risk level constants\n4. Store risk classification in IR\n\n**Hot Path Cost:** ~6 ticks\n\n**Use Cases:**\n- Financial risk assessment\n- Security risk flags\n- Operational risk indicators\n\n### 2.4. Provenance Assertions (10% of Runtime)\n\n**Pattern:**\n```sparql\nCONSTRUCT { ?action ex:hasReceipt ?receipt } WHERE { ?action ex:executed true }\n```\n\n**Hardcoded Knowledge:**\n- Template: `(?action, ex:hasReceipt, ?receipt)`\n- `p_const = ex:hasReceipt` (fixed)\n- `o_const = ?receipt` (receipt ID - can be precomputed)\n- Pattern: Provenance structure is fixed\n\n**Rust AOT Preparation:**\n1. Precompute receipt IDs from span IDs\n2. Generate specialized function: `knhk_construct8_emit_8_provenance()`\n3. Precompute receipt template structure\n4. Store provenance template in IR\n\n**Hot Path Cost:** ~6 ticks\n\n**Use Cases:**\n- Audit trail generation\n- Provenance tracking\n- Receipt generation\n\n### 2.5. Type Classification (10% of Runtime)\n\n**Pattern:**\n```sparql\nCONSTRUCT { ?resource rdf:type ?type } WHERE { ?resource ex:hasSchema ?schema . ?schema ex:definesType ?type }\n```\n\n**Hardcoded Knowledge:**\n- Template: `(?resource, rdf:type, ?type)`\n- `p_const = rdf:type` (fixed)\n- `o_const = ?type` (from schema - can be precomputed)\n- Pattern: Schema→type mappings are static\n\n**Rust AOT Preparation:**\n1. Precompute schema→type mappings at warm path\n2. Generate specialized function: `knhk_construct8_emit_8_type()`\n3. Precompute type constants\n4. Store type template in IR\n\n**Hot Path Cost:** ~6 ticks\n\n**Use Cases:**\n- Schema validation\n- Type inference\n- RDF type materialization\n\n### 2.6. Entitlement Sets (5% of Runtime)\n\n**Pattern:**\n```sparql\nCONSTRUCT { ?user ex:entitled ?resource } WHERE { ?user ex:role ?role . ?role ex:canAccess ?resource }\n```\n\n**Hardcoded Knowledge:**\n- Template: `(?user, ex:entitled, ?resource)`\n- `p_const = ex:entitled` (fixed)\n- `o_const = ?resource` (from role→resource mapping - can be precomputed)\n- Pattern: Role→resource mappings are relatively static\n\n**Rust AOT Preparation:**\n1. Precompute role→resource mappings at warm path\n2. Generate specialized function: `knhk_construct8_emit_8_entitlement()`\n3. Precompute entitlement sets\n4. Store entitlement template in IR\n\n**Hot Path Cost:** ~6 ticks\n\n**Use Cases:**\n- Access control lists\n- Resource entitlements\n- Permission sets\n\n### 2.7. Status Flags (5% of Runtime)\n\n**Pattern:**\n```sparql\nCONSTRUCT { ?process ex:status ?status } WHERE { ?process ex:state ?state . ?state ex:mapsToStatus ?status }\n```\n\n**Hardcoded Knowledge:**\n- Template: `(?process, ex:status, ?status)`\n- `p_const = ex:status` (fixed)\n- `o_const = ?status` (from state→status mapping - can be precomputed)\n- Pattern: State→status mappings are deterministic\n\n**Rust AOT Preparation:**\n1. Precompute state→status mappings at warm path\n2. Generate specialized function: `knhk_construct8_emit_8_status()`\n3. Precompute status constants\n4. Store status template in IR\n\n**Hot Path Cost:** ~6 ticks\n\n**Use Cases:**\n- Process state materialization\n- Status tracking\n- Workflow state flags\n\n### 2.8. Delta Assertions (5% of Runtime)\n\n**Pattern:**\n```sparql\nCONSTRUCT { ?delta ex:added ?triple } WHERE { ?delta ex:adds ?triple }\n```\n\n**Hardcoded Knowledge:**\n- Template: `(?delta, ex:added, ?triple)`\n- `p_const = ex:added` (fixed)\n- `o_const = ?triple` (from delta - computed at warm path)\n- Pattern: Delta structure is fixed\n\n**Rust AOT Preparation:**\n1. Precompute delta assertions at warm path\n2. Generate specialized function: `knhk_construct8_emit_8_delta()`\n3. Precompute delta structure\n4. Store delta template in IR\n\n**Hot Path Cost:** ~6 ticks\n\n**Use Cases:**\n- Change tracking\n- Delta generation\n- Event materialization\n\n## 3. Hardcoded Knowledge Summary\n\n### What Can Be 100% Hardcoded (Zero Hot Path Cost):\n\n1. **Template Predicates**: `ex:hasAccess`, `rdf:type`, `ex:riskLevel`, etc.\n   - Cost: 0 ticks (compile-time constants)\n\n2. **Template Objects**: `:Compliant`, `:Allowed`, `:Denied`, etc.\n   - Cost: 0 ticks (compile-time constants)\n\n3. **Length Masks**: For known `len` values (1-8)\n   - Cost: 0 ticks (compile-time constants)\n\n4. **Pattern Masks**: All-nonzero, all-zero, sparse patterns\n   - Cost: 0 ticks (warm-path precomputation)\n\n5. **Broadcast Vectors**: For common constants\n   - Cost: 0 ticks (compile-time optimization)\n\n6. **Function Selection**: Optimal specialized function variant\n   - Cost: 0 ticks (warm-path analysis)\n\n### What Must Be Computed at Runtime (Minimal Cost):\n\n1. **Subject Values**: From input array `S_base[off..off+len]`\n   - Cost: ~4 ticks (SIMD loads)\n\n2. **Mask Generation**: For unknown patterns\n   - Cost: ~4 ticks (SIMD comparisons) - but can be eliminated if pattern known\n\n3. **Blend Operations**: Conditional selection based on masks\n   - Cost: ~8 ticks (SIMD blends)\n\n4. **Store Operations**: Writing results to output arrays\n   - Cost: ~12 ticks (SIMD stores)\n\n5. **Mask Extraction**: Building bitmask for output\n   - Cost: ~4 ticks (lane extraction) - but can overlap with stores\n\n## 4. 80/20 Optimization Strategy\n\n### Priority 1: Hardcode Top 3 Use Cases (80% of Value)\n\n1. **Authorization Reflex** (30% of runtime)\n   - Hardcode: `ex:hasAccess` predicate, common permission sets\n   - Generate: `knhk_construct8_emit_8_auth()` specialized function\n   - Expected savings: ~2 ticks (constant optimization + pattern detection)\n\n2. **Compliance Classification** (20% of runtime)\n   - Hardcode: `rdf:type :Compliant` template, all-nonzero pattern\n   - Generate: `knhk_construct8_emit_8_compliant()` specialized function\n   - Expected savings: ~4 ticks (skip mask generation)\n\n3. **Risk Flag Generation** (15% of runtime)\n   - Hardcode: `ex:riskLevel` predicate, risk level constants\n   - Generate: `knhk_construct8_emit_8_risk()` specialized function\n   - Expected savings: ~1 tick (constant optimization)\n\n**Total Coverage:** 65% of runtime use cases\n\n### Priority 2: Generic Hardcoding (Remaining 35%)\n\n4. **Length Specialization**: Generate functions for len ∈ {1, 2, 3, 4, 5, 6, 7, 8}\n   - Coverage: All use cases\n   - Expected savings: ~0.25 ticks per call\n\n5. **Pattern Detection**: Analyze inputs for all-nonzero/all-zero patterns\n   - Coverage: ~40% of use cases (authorization, compliance often all-nonzero)\n   - Expected savings: ~4 ticks per call (when pattern detected)\n\n6. **Constant Propagation**: Precompute common `p_const`/`o_const` pairs\n   - Coverage: ~60% of use cases (enterprise templates are stable)\n   - Expected savings: ~1 tick per call\n\n## 5. Rust AOT Implementation Plan\n\n### Phase 1: Template Registry (Build-Time)\n\n```rust\n// rust/knhk-aot/src/templates.rs\npub struct ConstructTemplate {\n    pub name: &'static str,\n    pub p_const: u64,        // Hardcoded predicate\n    pub o_const: Option<u64>, // Hardcoded object (if constant)\n    pub pattern_hint: PatternType, // Expected pattern\n    pub len_range: Range<u8>, // Expected length range\n}\n\npub const TEMPLATES: &[ConstructTemplate] = &[\n    ConstructTemplate {\n        name: \"authorization\",\n        p_const: hash_iri(\"ex:hasAccess\"),\n        o_const: None,  // Variable (from role grants)\n        pattern_hint: PatternType::AllNonZero,\n        len_range: 1..5,\n    },\n    ConstructTemplate {\n        name: \"compliance\",\n        p_const: hash_iri(\"rdf:type\"),\n        o_const: Some(hash_iri(\":Compliant\")),\n        pattern_hint: PatternType::AllNonZero,\n        len_range: 1..8,\n    },\n    // ... more templates\n];\n```\n\n### Phase 2: Code Generation (Build-Time)\n\n```rust\n// rust/knhk-aot/build.rs\nfn generate_specialized_functions() {\n    for template in TEMPLATES {\n        for len in template.len_range {\n            let code = generate_function(template, len);\n            write_to_file(&format!(\"construct8_{}_len{}.c\", template.name, len), code);\n        }\n    }\n}\n```\n\n### Phase 3: Runtime Selection (Warm Path)\n\n```rust\n// rust/knhk-aot/src/dispatch.rs\npub fn select_optimal_function(\n    template: &ConstructTemplate,\n    len: u8,\n    zero_hint: u8\n) -> Construct8Fn {\n    match (template.name, len, zero_hint) {\n        (\"authorization\", 4, 0x00) => knhk_construct8_emit_8_auth_len4_all_nonzero,\n        (\"compliance\", 8, 0x00) => knhk_construct8_emit_8_compliant_len8_all_nonzero,\n        // ... more cases\n        _ => knhk_construct8_emit_8_generic, // Fallback\n    }\n}\n```\n\n## 6. Expected Performance Impact\n\n### Current Performance: ~42 ticks\n\n### With Hardcoded Knowledge Optimizations:\n\n**Best Case (All Optimizations Applied):**\n- Authorization (30%): 42 → 36 ticks (hardcoded constants)\n- Compliance (20%): 42 → 34 ticks (all-nonzero pattern)\n- Risk (15%): 42 → 37 ticks (hardcoded constants)\n- Remaining (35%): 42 → 38 ticks (length specialization)\n\n**Weighted Average:** ~36 ticks (still exceeds 8-tick budget, but 14% improvement)\n\n**Critical Insight:** Even with all hardcoding, we still need runtime optimizations (ILP overlap, store reduction) to hit 8 ticks.\n\n## 7. Hardcoded Knowledge Checklist\n\n### ✅ Can Be Hardcoded (Zero Hot Path Cost):\n- [x] Template predicates (`p_const` values)\n- [x] Template objects (`o_const` values when constant)\n- [x] Length mask bits (for known `len` values)\n- [x] Pattern masks (all-nonzero, all-zero)\n- [x] Broadcast vectors (for common constants)\n- [x] Function selection (optimal variant)\n- [x] Zero-position hints (warm-path analysis)\n- [x] Alignment guarantees (Rust allocation)\n\n### ❌ Cannot Be Hardcoded (Runtime Required):\n- [ ] Subject values (from input array)\n- [ ] Mask generation (for unknown patterns)\n- [ ] Blend operations (SIMD conditional selection)\n- [ ] Store operations (memory writes)\n- [ ] Dynamic mask extraction (when pattern unknown)\n\n## 8. Conclusion\n\n**Hardcoded Knowledge Benefits:**\n- **Authorization**: ~2 ticks saved (30% of runtime)\n- **Compliance**: ~4 ticks saved (20% of runtime)\n- **Risk**: ~1 tick saved (15% of runtime)\n- **Generic**: ~0.25 ticks saved (length specialization)\n\n**Total Potential Savings:** ~2-4 ticks per call (depending on use case)\n\n**Critical Finding:** Hardcoded knowledge alone is **not sufficient** to reach 8-tick budget. We still need:\n1. ILP overlap optimizations\n2. Store count reduction\n3. Better instruction scheduling\n\n**However**, hardcoded knowledge provides the **foundation** for specialized functions that can then be further optimized with runtime techniques.\n\n**Recommendation:** Implement hardcoded knowledge optimizations **first** (foundation), then apply runtime optimizations (ILP, stores) to specialized functions.\n\n"
        }
    ]
}