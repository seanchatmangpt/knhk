{
    "sourceFile": "docs/construct8-sparql-10.2-optimizations.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1762370935090,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1762370935090,
            "name": "Commit-0",
            "content": "# CONSTRUCT Query Optimization: What Can Be Hardcoded/AOT (SPARQL 10.2)\n\n## Overview\n\nAnalysis of SPARQL CONSTRUCT queries (Section 10.2) to identify what can be **assumed**, **hardcoded**, or **AOT-optimized** for the 8-tick hot path and warm path execution.\n\n## 1. Template Structure (100% Hardcodable)\n\n### 1.1. Fixed Template Patterns\n\n**From SPARQL Spec 10.2:**\n```sparql\nCONSTRUCT { <http://example.org/person#Alice> vcard:FN ?name }\nWHERE { ?x foaf:name ?name }\n```\n\n**What Can Be Hardcoded:**\n- **Subject**: If constant (e.g., `<http://example.org/person#Alice>`), hardcode as `uint64_t`\n- **Predicate**: If constant (e.g., `vcard:FN`), hardcode as `uint64_t`\n- **Object**: If variable (e.g., `?name`), known at runtime from WHERE clause\n\n**AOT Optimization:**\n```c\n// Compile-time specialization\ntypedef struct {\n  uint64_t s_const;      // Hardcoded subject (0 = variable)\n  uint64_t p_const;      // Hardcoded predicate (0 = variable)\n  uint64_t o_const;      // Hardcoded object (0 = variable)\n  uint8_t s_is_var;      // 1 if subject is variable\n  uint8_t p_is_var;      // 1 if predicate is variable\n  uint8_t o_is_var;      // 1 if object is variable\n} construct_template_t;\n\n// AOT-generated specialized functions\nstatic inline size_t knhk_construct8_emit_8_s_const_p_const_o_var(\n  const uint64_t *S_base, uint64_t off, uint64_t len,\n  uint64_t s_const, uint64_t p_const,\n  const uint64_t *O_base,  // Object comes from WHERE clause\n  uint64_t *out_S, uint64_t *out_P, uint64_t *out_O\n) {\n  // Hardcoded: s_const, p_const\n  // Variable: O_base[off..off+len]\n  // No need to broadcast s_const/p_const (compile-time constants)\n  // ...\n}\n```\n\n**Savings:** ~1 tick (eliminates runtime broadcasts for constants)\n\n### 1.2. Ground Triples (100% Hardcodable)\n\n**From SPARQL Spec 10.2:**\n> \"The graph template can contain triples with no variables (known as ground or explicit triples), and these also appear in the output RDF graph.\"\n\n**Example:**\n```sparql\nCONSTRUCT {\n  <http://example.org/person#Alice> vcard:FN \"Alice\" .\n  <http://example.org/person#Alice> vcard:ORG \"Example Corp\" .\n  ?x vcard:FN ?name .\n}\nWHERE { ?x foaf:name ?name }\n```\n\n**What Can Be Hardcoded:**\n- Ground triples (no variables) are **completely constant**\n- Can be emitted **once** at warm path time, not per solution\n- No hot path execution needed for ground triples\n\n**AOT Optimization:**\n```rust\n// Rust warm path: Precompute ground triples\npub struct ConstructTemplate {\n    pub ground_triples: Vec<(u64, u64, u64)>,  // (s, p, o) constants\n    pub template_triples: Vec<TemplateTriple>, // Variable triples\n}\n\n// Warm path: Emit ground triples once\nfn emit_ground_triples(template: &ConstructTemplate, output: &mut Vec<Quad>) {\n    for (s, p, o) in &template.ground_triples {\n        output.push(Quad { s: *s, p: *p, o: *o, g: 0 });\n    }\n}\n\n// Hot path: Only emit variable triples\nfn construct8_variable_triples(...) {\n    // Only processes variable triples (≤8)\n}\n```\n\n**Savings:** Eliminates ground triple emission from hot path entirely\n\n### 1.3. Variable Binding Patterns\n\n**Analysis:**\n- **Subject Variable** (`?x`): Bound from WHERE clause → Known at runtime\n- **Predicate Variable** (`?p`): Rare in CONSTRUCT templates → Usually constant\n- **Object Variable** (`?o`): Bound from WHERE clause → Known at runtime\n\n**What Can Be Hardcoded:**\n- **Variable positions**: Known at compile time (template analysis)\n- **Variable sources**: WHERE clause binding → Can be precomputed at warm path\n\n**AOT Optimization:**\n```rust\n// Rust AOT: Analyze template and WHERE clause\npub fn analyze_template(template: &str, where: &str) -> TemplateAnalysis {\n    let mut analysis = TemplateAnalysis::new();\n    \n    // Identify variable positions\n    if template.contains(\"?s\") {\n        analysis.s_is_var = true;\n        analysis.s_source = find_binding_source(\"?s\", where);\n    }\n    if template.contains(\"?p\") {\n        analysis.p_is_var = true;\n        analysis.p_source = find_binding_source(\"?p\", where);\n    }\n    if template.contains(\"?o\") {\n        analysis.o_is_var = true;\n        analysis.o_source = find_binding_source(\"?o\", where);\n    }\n    \n    // Generate specialized function\n    generate_specialized_function(&analysis);\n    analysis\n}\n```\n\n## 2. Blank Node Labels (AOT Optimizable)\n\n### 2.1. Blank Node Scoping\n\n**From SPARQL Spec 10.2.1:**\n> \"The blank node labels are scoped to the template for each solution. If the same label occurs twice in a template, then there will be one blank node created for each query solution.\"\n\n**Example:**\n```sparql\nCONSTRUCT { ?x vcard:N _:v .\n            _:v vcard:givenName ?gname .\n            _:v vcard:familyName ?fname }\n```\n\n**What Can Be Hardcoded:**\n- **Blank node count**: Known from template analysis\n- **Blank node structure**: Known from template structure\n- **Blank node allocation**: Can be pre-allocated (per solution)\n\n**AOT Optimization:**\n```rust\n// Rust AOT: Analyze blank node structure\npub struct BlankNodeTemplate {\n    pub bnode_count: u8,              // Max blank nodes per solution\n    pub bnode_structure: Vec<BNodeTriple>, // Structure of blank node triples\n}\n\n// Warm path: Pre-allocate blank node IDs\nfn allocate_blank_nodes(template: &BlankNodeTemplate, solution_count: usize) -> Vec<u64> {\n    let mut bnode_ids = Vec::new();\n    for _ in 0..(template.bnode_count * solution_count) {\n        bnode_ids.push(generate_blank_node_id());\n    }\n    bnode_ids\n}\n\n// Hot path: Use pre-allocated blank node IDs\nfn construct8_with_bnodes(\n    bnode_ids: &[u64],\n    bnode_offset: usize,\n    template: &BlankNodeTemplate,\n    // ... other args\n) {\n    // Use pre-allocated IDs (no allocation in hot path)\n}\n```\n\n**Savings:** Eliminates blank node allocation from hot path\n\n### 2.2. Blank Node Label Mapping\n\n**What Can Be Hardcoded:**\n- **Label→ID mapping**: Can be precomputed at warm path\n- **ID generation**: Can use deterministic ID generation (hash-based)\n\n**AOT Optimization:**\n```rust\n// Warm path: Generate deterministic blank node IDs\nfn generate_bnode_id(solution_id: u64, bnode_label: &str) -> u64 {\n    // Deterministic: hash(solution_id, bnode_label)\n    // Ensures same solution → same blank node ID\n    hash64(solution_id, bnode_label)\n}\n```\n\n**Savings:** Deterministic IDs enable better caching/optimization\n\n## 3. Graph Access (AOT Optimizable)\n\n### 3.1. Named Graph Access\n\n**From SPARQL Spec 10.2.2:**\n```sparql\nCONSTRUCT { ?s ?p ?o }\nWHERE { GRAPH <http://example.org/aGraph> { ?s ?p ?o } }\n```\n\n**What Can Be Hardcoded:**\n- **Graph IRI**: If constant (e.g., `<http://example.org/aGraph>`), hardcode as `uint64_t`\n- **Graph selection**: Can be precomputed at warm path (graph lookup)\n\n**AOT Optimization:**\n```rust\n// Rust AOT: Analyze GRAPH clause\npub fn analyze_graph_clause(where: &str) -> GraphAccess {\n    if let Some(graph_iri) = extract_constant_graph(where) {\n        GraphAccess::Constant(graph_iri)  // Hardcode graph IRI\n    } else {\n        GraphAccess::Variable  // Variable graph (rare)\n    }\n}\n\n// Warm path: Pre-select graph\nfn select_graph(ctx: &Context, graph_iri: u64) -> Option<GraphHandle> {\n    ctx.graphs.get(&graph_iri)  // O(1) lookup\n}\n\n// Hot path: Use pre-selected graph handle\nfn construct8_from_graph(\n    graph: &GraphHandle,  // Pre-selected graph\n    // ... other args\n) {\n    // Direct access to graph data (no lookup in hot path)\n}\n```\n\n**Savings:** Eliminates graph lookup from hot path\n\n### 3.2. Conditional Graph Access\n\n**From SPARQL Spec 10.2.2:**\n```sparql\nCONSTRUCT { ?s ?p ?o }\nWHERE {\n  GRAPH ?g { ?s ?p ?o } .\n  { ?g dc:publisher <http://www.w3.org/> } .\n  FILTER ( app:customDate(?date) > \"2005-02-28T00:00:00Z\"^^xsd:dateTime ) .\n}\n```\n\n**What Can Be Hardcoded:**\n- **Graph filter conditions**: Can be precomputed at warm path\n- **Graph selection**: Can be done at warm path, hot path only processes selected graphs\n\n**AOT Optimization:**\n```rust\n// Warm path: Pre-filter graphs based on conditions\nfn prefilter_graphs(ctx: &Context, conditions: &GraphConditions) -> Vec<GraphHandle> {\n    ctx.graphs\n        .iter()\n        .filter(|(_, graph)| matches_conditions(graph, conditions))\n        .map(|(_, graph)| graph.clone())\n        .collect()\n}\n\n// Hot path: Process only pre-filtered graphs\nfn construct8_from_filtered_graphs(\n    graphs: &[GraphHandle],  // Pre-filtered graphs\n    // ... other args\n) {\n    // Process graphs sequentially (no filtering in hot path)\n}\n```\n\n**Savings:** Eliminates graph filtering from hot path\n\n## 4. Solution Modifiers (AOT Optimizable)\n\n### 4.1. ORDER BY\n\n**From SPARQL Spec 10.2.3:**\n```sparql\nCONSTRUCT { [] foaf:name ?name }\nWHERE { [] foaf:name ?name ; site:hits ?hits }\nORDER BY desc(?hits)\nLIMIT 2\n```\n\n**What Can Be Hardcoded:**\n- **Sort key**: Known from ORDER BY clause (e.g., `?hits`)\n- **Sort direction**: Known from ORDER BY clause (e.g., `desc`)\n- **Sort operation**: Can be precomputed at warm path (pre-sort solutions)\n\n**AOT Optimization:**\n```rust\n// Rust AOT: Analyze ORDER BY clause\npub fn analyze_order_by(order_by: &str) -> OrderBy {\n    if order_by.contains(\"desc\") {\n        OrderBy::Descending(extract_variable(order_by))\n    } else {\n        OrderBy::Ascending(extract_variable(order_by))\n    }\n}\n\n// Warm path: Pre-sort solutions\nfn pre_sort_solutions(solutions: &mut Vec<Solution>, order_by: &OrderBy) {\n    match order_by {\n        OrderBy::Ascending(var) => {\n            solutions.sort_by_key(|s| s.get(var));\n        }\n        OrderBy::Descending(var) => {\n            solutions.sort_by_key(|s| Reverse(s.get(var)));\n        }\n    }\n}\n\n// Hot path: Process pre-sorted solutions (no sorting)\nfn construct8_from_sorted_solutions(\n    solutions: &[Solution],  // Pre-sorted\n    // ... other args\n) {\n    // Process solutions in order (already sorted)\n}\n```\n\n**Savings:** Eliminates sorting from hot path\n\n### 4.2. LIMIT\n\n**What Can Be Hardcoded:**\n- **Limit value**: Known from LIMIT clause (e.g., `LIMIT 2`)\n- **Limit application**: Can be applied at warm path (truncate solutions)\n\n**AOT Optimization:**\n```rust\n// Warm path: Apply LIMIT before hot path\nfn apply_limit(solutions: &mut Vec<Solution>, limit: usize) {\n    solutions.truncate(limit);\n}\n\n// Hot path: Process limited solutions (no limit checking)\nfn construct8_from_limited_solutions(\n    solutions: &[Solution],  // Already limited\n    // ... other args\n) {\n    // Process all solutions (limit already applied)\n}\n```\n\n**Savings:** Eliminates limit checking from hot path\n\n### 4.3. OFFSET\n\n**What Can Be Hardcoded:**\n- **Offset value**: Known from OFFSET clause\n- **Offset application**: Can be applied at warm path (skip solutions)\n\n**AOT Optimization:**\n```rust\n// Warm path: Apply OFFSET before hot path\nfn apply_offset(solutions: &mut Vec<Solution>, offset: usize) {\n    solutions.drain(..offset);\n}\n\n// Hot path: Process offset solutions (no offset checking)\nfn construct8_from_offset_solutions(\n    solutions: &[Solution],  // Already offset\n    // ... other args\n) {\n    // Process all solutions (offset already applied)\n}\n```\n\n**Savings:** Eliminates offset checking from hot path\n\n## 5. WHERE Clause Patterns (AOT Optimizable)\n\n### 5.1. Triple Pattern Analysis\n\n**What Can Be Hardcoded:**\n- **Pattern structure**: Known from WHERE clause\n- **Variable bindings**: Can be precomputed at warm path\n- **Join patterns**: Can be optimized at warm path (pre-join)\n\n**AOT Optimization:**\n```rust\n// Rust AOT: Analyze WHERE clause patterns\npub fn analyze_where_clause(where: &str) -> WhereAnalysis {\n    let patterns = parse_triple_patterns(where);\n    let variables = extract_variables(&patterns);\n    let joins = identify_joins(&patterns);\n    \n    WhereAnalysis {\n        patterns,\n        variables,\n        joins,\n        // Generate optimized execution plan\n        execution_plan: generate_execution_plan(&patterns, &joins),\n    }\n}\n\n// Warm path: Pre-join data\nfn pre_join_data(ctx: &Context, where_analysis: &WhereAnalysis) -> JoinedData {\n    // Execute joins at warm path\n    // Return pre-joined data for hot path\n}\n\n// Hot path: Process pre-joined data (no joins)\nfn construct8_from_prejoined_data(\n    joined_data: &JoinedData,  // Pre-joined\n    // ... other args\n) {\n    // Process joined data directly (no joins in hot path)\n}\n```\n\n**Savings:** Eliminates joins from hot path\n\n### 5.2. FILTER Conditions\n\n**What Can Be Hardcoded:**\n- **Filter expressions**: Can be analyzed at compile time\n- **Filter evaluation**: Can be done at warm path (pre-filter solutions)\n\n**AOT Optimization:**\n```rust\n// Warm path: Pre-filter solutions\nfn pre_filter_solutions(solutions: &mut Vec<Solution>, filter: &FilterExpr) {\n    solutions.retain(|s| evaluate_filter(s, filter));\n}\n\n// Hot path: Process pre-filtered solutions (no filtering)\nfn construct8_from_filtered_solutions(\n    solutions: &[Solution],  // Pre-filtered\n    // ... other args\n) {\n    // Process all solutions (filter already applied)\n}\n```\n\n**Savings:** Eliminates filter evaluation from hot path\n\n### 5.3. UNION Patterns\n\n**What Can Be Hardcoded:**\n- **UNION branches**: Known from WHERE clause\n- **UNION selection**: Can be done at warm path (pre-select branch)\n\n**AOT Optimization:**\n```rust\n// Warm path: Pre-select UNION branch\nfn pre_select_union_branch(ctx: &Context, union: &UnionPattern) -> Vec<Solution> {\n    // Evaluate each branch, select best branch\n    // Return solutions from selected branch\n}\n\n// Hot path: Process pre-selected branch (no UNION evaluation)\nfn construct8_from_union_solutions(\n    solutions: &[Solution],  // Pre-selected from UNION\n    // ... other args\n) {\n    // Process solutions directly (no UNION in hot path)\n}\n```\n\n**Savings:** Eliminates UNION evaluation from hot path\n\n## 6. CONSTRUCT8-Specific Optimizations\n\n### 6.1. Fixed Template Assumptions\n\n**For CONSTRUCT8 (≤8 triples):**\n\n**What Can Be Hardcoded:**\n- **Template size**: Known at compile time (≤8 triples)\n- **Template structure**: Known at compile time (fixed template)\n- **Variable bindings**: Precomputed at warm path\n\n**AOT Optimization:**\n```rust\n// Rust AOT: Generate CONSTRUCT8 template\npub fn generate_construct8_template(template: &str) -> Construct8Template {\n    let triples = parse_template_triples(template);\n    \n    assert!(triples.len() <= 8, \"CONSTRUCT8 template must have ≤8 triples\");\n    \n    Construct8Template {\n        triples,\n        // Precompute constant values\n        constants: extract_constants(&triples),\n        // Precompute variable positions\n        variable_positions: extract_variable_positions(&triples),\n    }\n}\n\n// Warm path: Bind variables, prepare hot path input\nfn prepare_construct8_input(\n    template: &Construct8Template,\n    solutions: &[Solution],\n) -> Construct8Input {\n    // Bind variables from solutions\n    // Prepare S, P, O arrays for hot path\n    // Precompute constants\n    Construct8Input {\n        S: bind_subjects(template, solutions),\n        P: bind_predicates(template, solutions),  // Usually constant\n        O: bind_objects(template, solutions),\n        len: solutions.len().min(8),\n    }\n}\n\n// Hot path: Execute CONSTRUCT8 (≤8 ticks)\nfn construct8_execute(input: &Construct8Input, output: &mut Construct8Output) {\n    knhk_construct8_emit_8(\n        input.S.as_ptr(),\n        input.off,\n        input.len,\n        input.p_const,  // Usually constant\n        input.o_const,  // May be constant\n        output.out_S.as_mut_ptr(),\n        output.out_P.as_mut_ptr(),\n        output.out_O.as_mut_ptr(),\n    );\n}\n```\n\n### 6.2. Illegal RDF Construct Detection\n\n**From SPARQL Spec 10.2:**\n> \"If any such instantiation produces a triple containing an unbound variable or an illegal RDF construct, such as a literal in subject or predicate position, then that triple is not included in the output RDF graph.\"\n\n**What Can Be Hardcoded:**\n- **Validation rules**: Known at compile time (RDF constraints)\n- **Validation checks**: Can be done at warm path (pre-validate solutions)\n\n**AOT Optimization:**\n```rust\n// Warm path: Pre-validate solutions\nfn pre_validate_solutions(solutions: &mut Vec<Solution>, template: &Construct8Template) {\n    solutions.retain(|s| {\n        // Validate each solution against template\n        validate_solution_against_template(s, template)\n    });\n}\n\n// Hot path: Process pre-validated solutions (no validation)\nfn construct8_from_validated_solutions(\n    solutions: &[Solution],  // Pre-validated\n    // ... other args\n) {\n    // All solutions are valid (no validation in hot path)\n}\n```\n\n**Savings:** Eliminates RDF validation from hot path\n\n## 7. Summary: What Can Be Hardcoded/AOT\n\n### 7.1. 100% Hardcodable (Zero Hot Path Cost)\n\n| Component | Hardcoding Strategy | Savings |\n|-----------|---------------------|---------|\n| **Ground Triples** | Emit at warm path once | Eliminates from hot path |\n| **Constant Predicates** | Compile-time constants | ~1 tick (no broadcast) |\n| **Constant Objects** | Compile-time constants | ~1 tick (no broadcast) |\n| **Constant Subjects** | Compile-time constants | ~1 tick (no broadcast) |\n| **Template Structure** | Fixed template analysis | Enables specialization |\n| **Blank Node Count** | Known from template | Pre-allocation possible |\n| **Graph IRI (constant)** | Hardcode graph lookup | Eliminates lookup |\n| **LIMIT Value** | Apply at warm path | Eliminates limit check |\n| **OFFSET Value** | Apply at warm path | Eliminates offset check |\n| **ORDER BY Key** | Pre-sort at warm path | Eliminates sorting |\n\n### 7.2. AOT Optimizable (Warm Path Precomputation)\n\n| Component | AOT Strategy | Savings |\n|-----------|--------------|---------|\n| **Variable Bindings** | Pre-bind at warm path | Eliminates binding from hot path |\n| **Blank Node IDs** | Pre-allocate at warm path | Eliminates allocation |\n| **Graph Selection** | Pre-select at warm path | Eliminates graph lookup |\n| **Solution Filtering** | Pre-filter at warm path | Eliminates filter evaluation |\n| **Solution Sorting** | Pre-sort at warm path | Eliminates sorting |\n| **Solution Limiting** | Pre-limit at warm path | Eliminates limit checking |\n| **Join Operations** | Pre-join at warm path | Eliminates joins |\n| **UNION Evaluation** | Pre-select at warm path | Eliminates UNION evaluation |\n| **RDF Validation** | Pre-validate at warm path | Eliminates validation |\n\n### 7.3. Runtime Required (Hot Path)\n\n| Component | Runtime Requirement | Notes |\n|-----------|---------------------|-------|\n| **Subject Values** | From WHERE clause bindings | Variable, but pre-bound |\n| **Object Values** | From WHERE clause bindings | Variable, but pre-bound |\n| **Solution Iteration** | Process each solution | Required, but pre-processed |\n| **Triple Emission** | Write to output arrays | Required, but optimized (SIMD) |\n\n## 8. Implementation Strategy\n\n### Phase 1: Template Analysis (Rust AOT)\n\n```rust\n// rust/knhk-aot/src/template_analyzer.rs\npub struct ConstructTemplateAnalyzer;\n\nimpl ConstructTemplateAnalyzer {\n    pub fn analyze(query: &str) -> TemplateAnalysis {\n        // 1. Parse CONSTRUCT template\n        let template = parse_construct_template(query);\n        \n        // 2. Identify constants vs variables\n        let constants = extract_constants(&template);\n        let variables = extract_variables(&template);\n        \n        // 3. Identify ground triples\n        let ground_triples = extract_ground_triples(&template);\n        \n        // 4. Analyze blank nodes\n        let blank_nodes = analyze_blank_nodes(&template);\n        \n        // 5. Analyze WHERE clause\n        let where_analysis = analyze_where_clause(query);\n        \n        // 6. Analyze solution modifiers\n        let modifiers = analyze_solution_modifiers(query);\n        \n        TemplateAnalysis {\n            template,\n            constants,\n            variables,\n            ground_triples,\n            blank_nodes,\n            where_analysis,\n            modifiers,\n        }\n    }\n}\n```\n\n### Phase 2: Warm Path Preprocessing (Rust)\n\n```rust\n// rust/knhk-hot/src/construct8_preprocessor.rs\npub fn preprocess_construct8(\n    analysis: &TemplateAnalysis,\n    ctx: &Context,\n    solutions: &[Solution],\n) -> Construct8Input {\n    // 1. Emit ground triples (once)\n    let mut output = emit_ground_triples(&analysis.ground_triples);\n    \n    // 2. Apply solution modifiers\n    let mut processed_solutions = apply_modifiers(solutions, &analysis.modifiers);\n    \n    // 3. Pre-validate solutions\n    let validated_solutions = pre_validate(&processed_solutions, &analysis);\n    \n    // 4. Pre-bind variables\n    let bound_data = pre_bind_variables(&validated_solutions, &analysis.variables);\n    \n    // 5. Pre-allocate blank nodes\n    let bnode_ids = pre_allocate_blank_nodes(&analysis.blank_nodes, validated_solutions.len());\n    \n    // 6. Prepare hot path input\n    Construct8Input {\n        S: bound_data.subjects,\n        P: bound_data.predicates,\n        O: bound_data.objects,\n        len: validated_solutions.len().min(8),\n        p_const: analysis.constants.predicate,\n        o_const: analysis.constants.object,\n        bnode_ids,\n    }\n}\n```\n\n### Phase 3: Hot Path Execution (C)\n\n```c\n// src/simd/construct.h (already implemented)\n// Hot path: Pure CONSTRUCT8 execution (≤8 ticks)\n// All preprocessing done at warm path\n```\n\n## 9. Expected Performance Impact\n\n### Current CONSTRUCT8 Performance: ~42 ticks\n\n### With Hardcoding/AOT Optimizations:\n\n**Ground Triples:** Eliminated from hot path (0 ticks saved per solution)\n\n**Constant Optimization:** ~1-2 ticks saved (no broadcasts)\n\n**Pre-validation:** ~2-4 ticks saved (no validation in hot path)\n\n**Pre-binding:** ~1-2 ticks saved (no binding in hot path)\n\n**Pre-modifiers:** ~2-4 ticks saved (no sorting/limiting in hot path)\n\n**Total Potential Savings:** ~8-14 ticks\n\n**Target Performance:** ~28-34 ticks (still exceeds 8-tick budget, but significant improvement)\n\n**Critical Insight:** Hardcoding/AOT alone is **not sufficient** to reach 8-tick budget. We still need:\n1. ILP overlap optimizations\n2. Store count reduction\n3. Better instruction scheduling\n\n## 10. Conclusion\n\n**Key Findings:**\n\n1. **100% Hardcodable:**\n   - Ground triples (emit at warm path)\n   - Constant predicates/objects/subjects (compile-time)\n   - Template structure (fixed template)\n   - Solution modifiers (apply at warm path)\n\n2. **AOT Optimizable:**\n   - Variable bindings (pre-bind at warm path)\n   - Blank node allocation (pre-allocate)\n   - Graph selection (pre-select)\n   - Solution filtering/sorting/limiting (pre-process)\n\n3. **Runtime Required:**\n   - Subject/object values (from pre-bound variables)\n   - Triple emission (SIMD-optimized)\n   - Solution iteration (pre-processed)\n\n**Recommendation:** Implement hardcoding/AOT optimizations **first** (foundation), then apply runtime optimizations (ILP, stores) to reach 8-tick budget.\n\n"
        }
    ]
}