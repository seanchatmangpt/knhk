{
    "sourceFile": "docs/rdf-parser-integration-plan.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1762376291508,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1762376291508,
            "name": "Commit-0",
            "content": "# Rust Turtle/RDF Parser Integration Plan\n\n## Overview\n\nIntegration of `rio_turtle` Rust library for production-ready RDF/Turtle parsing in KNHK, replacing the simplified parser currently in `rust/knhk-etl/src/lib.rs`.\n\n## Current State\n\n### Existing Implementation\n- **C Code**: Uses Raptor (C library) in `src/rdf.c` for file-based parsing\n- **Rust Code**: Simplified Turtle parser in `rust/knhk-etl/src/lib.rs` (`parse_rdf_turtle`)\n  - Basic line-by-line parsing\n  - Limited Turtle syntax support\n  - No prefix resolution\n  - No blank node handling\n  - No base URI resolution\n\n### CONVO.txt References\n- Mentions `rio_api = \"0.8\"` and `rio_turtle = \"0.8\"` for AOT dependencies\n- Turtle parsing needed for `ttl2csv` conversion tool\n\n## Why `rio_turtle`?\n\n### Advantages\n1. **Pure Rust**: No FFI overhead, better integration with Rust codebase\n2. **Streaming**: Memory-efficient parsing from `BufRead` implementations\n3. **No External Dependencies**: Only uses Rust standard library\n4. **Full Turtle Support**: Complete Turtle syntax (prefixes, blank nodes, base URIs)\n5. **RDF-star Support**: Supports RDF-star syntaxes\n6. **Multiple Formats**: N-Triples, N-Quads, Turtle, TriG\n7. **Zero-copy**: Can work with byte slices directly\n\n### Comparison with Alternatives\n\n| Library | Pros | Cons |\n|---------|------|------|\n| **rio_turtle** | Pure Rust, streaming, no deps, RDF-star | |\n| **oxrdfio** | Part of Oxigraph ecosystem | Requires more dependencies |\n| **sophia_turtle** | Based on rio_turtle | Additional abstraction layer |\n| **harriet** | AST-based, preserves format | More complex for simple use cases |\n\n## Integration Plan\n\n### Phase 1: Add Dependencies\n\n**Files to Update:**\n- `rust/knhk-etl/Cargo.toml` - Add `rio_turtle` dependency\n- `rust/knhk-aot/Cargo.toml` - Add `rio_turtle` and `rio_api` dependencies (as mentioned in CONVO.txt)\n\n### Phase 2: Replace Simplified Parser\n\n**Files to Update:**\n- `rust/knhk-etl/src/lib.rs` - Replace `parse_rdf_turtle()` implementation\n\n**Key Changes:**\n1. Use `rio_turtle::TurtleParser` for parsing\n2. Handle `rio_api::ParseError` properly\n3. Convert `rio_api::Triple` to `RawTriple`\n4. Support prefix resolution\n5. Handle blank nodes\n6. Support base URI resolution\n\n### Phase 3: Integration Points\n\n**Use Cases:**\n1. **ETL Pipeline**: `IngestStage::parse_rdf_turtle()` - Replace simplified parser\n2. **AOT Tool**: `ttl2csv` conversion tool (mentioned in CONVO.txt)\n3. **Connectors**: Kafka connector parsing RDF/Turtle messages\n4. **CLI**: `admit` command parsing RDF deltas\n\n### Phase 4: Error Handling\n\n**Requirements:**\n- Proper error reporting with line numbers\n- Parse error recovery (where possible)\n- Invalid syntax handling\n- Memory-efficient error handling\n\n### Phase 5: Testing\n\n**Test Cases:**\n1. Basic triple parsing\n2. Prefix resolution\n3. Blank node handling\n4. Base URI resolution\n5. Literal handling (simple, typed, language-tagged)\n6. Error cases (invalid syntax)\n7. Large file parsing (streaming)\n8. RDF-star syntax (if needed)\n\n## Implementation Details\n\n### Dependencies\n\n```toml\n# rust/knhk-etl/Cargo.toml\n[dependencies]\nrio_turtle = \"0.8\"\nrio_api = \"0.8\"  # For Triple types and error handling\n```\n\n```toml\n# rust/knhk-aot/Cargo.toml\n[dependencies]\nrio_turtle = \"0.8\"\nrio_api = \"0.8\"\n```\n\n### API Design\n\n```rust\n// rust/knhk-etl/src/lib.rs\n\nuse rio_api::parser::TriplesParser;\nuse rio_turtle::TurtleParser;\nuse rio_api::model::{NamedNode, BlankNode, Literal, Triple, Term};\n\nimpl IngestStage {\n    /// Parse RDF/Turtle content using rio_turtle\n    pub fn parse_rdf_turtle(&self, content: &str) -> Result<Vec<RawTriple>, PipelineError> {\n        let mut triples = Vec::new();\n        let mut parser = TurtleParser::new(content.as_bytes(), None)?;\n        \n        parser.parse_all(&mut |triple| {\n            let raw = Self::convert_triple(triple)?;\n            triples.push(raw);\n            Ok(())\n        })?;\n        \n        Ok(triples)\n    }\n    \n    /// Convert rio_api::Triple to RawTriple\n    fn convert_triple(triple: &Triple) -> Result<RawTriple, PipelineError> {\n        Ok(RawTriple {\n            subject: Self::term_to_string(triple.subject)?,\n            predicate: Self::term_to_string(triple.predicate)?,\n            object: Self::term_to_string(triple.object)?,\n            graph: None,  // N-Quads support can be added later\n        })\n    }\n    \n    /// Convert rio_api::Term to String\n    fn term_to_string(term: &Term) -> Result<String, PipelineError> {\n        match term {\n            Term::NamedNode(named) => Ok(named.iri.to_string()),\n            Term::BlankNode(blank) => Ok(format!(\"_:{}\", blank.id)),\n            Term::Literal(literal) => {\n                match literal {\n                    Literal::Simple { value } => Ok(format!(\"\\\"{}\\\"\", value)),\n                    Literal::LanguageTaggedString { value, language } => {\n                        Ok(format!(\"\\\"{}\\\"@{}\", value, language))\n                    }\n                    Literal::Typed { value, datatype } => {\n                        Ok(format!(\"\\\"{}\\\"^^{}\", value, datatype.iri))\n                    }\n                }\n            }\n        }\n    }\n}\n```\n\n### Error Handling\n\n```rust\nuse rio_api::parser::ParseError;\n\nimpl From<ParseError> for PipelineError {\n    fn from(err: ParseError) -> Self {\n        PipelineError::ParseError(format!(\n            \"RDF parse error at line {}: {}\",\n            err.location().line(),\n            err.message()\n        ))\n    }\n}\n```\n\n### Streaming Support\n\n```rust\nuse std::io::BufRead;\n\n/// Parse RDF/Turtle from a BufRead stream\npub fn parse_rdf_turtle_stream<R: BufRead>(\n    reader: R,\n    base_uri: Option<&str>\n) -> Result<Vec<RawTriple>, PipelineError> {\n    let mut triples = Vec::new();\n    let base = base_uri.map(|u| NamedNode::new(u).map_err(|_| PipelineError::InvalidUri)?);\n    let mut parser = TurtleParser::new(reader, base.as_ref())?;\n    \n    parser.parse_all(&mut |triple| {\n        triples.push(Self::convert_triple(triple)?);\n        Ok(())\n    })?;\n    \n    Ok(triples)\n}\n```\n\n## Migration Strategy\n\n### Step 1: Add Dependencies\n- Update `Cargo.toml` files\n- Run `cargo build` to verify dependencies\n\n### Step 2: Implement rio_turtle Parser\n- Replace `parse_rdf_turtle()` implementation\n- Add conversion functions\n- Add error handling\n\n### Step 3: Update Tests\n- Update existing tests to use new parser\n- Add new test cases for Turtle features\n\n### Step 4: Integration Testing\n- Test with existing ETL pipeline\n- Test with connectors\n- Test with CLI commands\n\n### Step 5: Performance Validation\n- Compare performance with Raptor (C)\n- Verify memory usage (streaming)\n- Validate ≤8 tick budget not affected (parsing is warm path)\n\n## Benefits\n\n1. **Production-Ready**: Full Turtle syntax support\n2. **Memory Efficient**: Streaming parser for large files\n3. **Pure Rust**: Better integration, no FFI overhead\n4. **Maintainable**: Standard Rust error handling\n5. **Extensible**: Easy to add N-Quads, TriG support later\n\n## Compatibility\n\n### Backward Compatibility\n- `RawTriple` structure remains the same\n- `parse_rdf_turtle()` API signature unchanged\n- Existing code using `parse_rdf_turtle()` continues to work\n\n### Forward Compatibility\n- Can add N-Quads support (graph field)\n- Can add TriG support (named graphs)\n- Can add RDF-star support (quoted triples)\n\n## Testing Strategy\n\n### Unit Tests\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_basic_triple() {\n        let content = r#\"\n            <http://example.org/alice> <http://example.org/name> \"Alice\" .\n        \"#;\n        let result = IngestStage::new(vec![], \"turtle\".to_string())\n            .parse_rdf_turtle(content)\n            .unwrap();\n        assert_eq!(result.len(), 1);\n    }\n    \n    #[test]\n    fn test_prefix() {\n        let content = r#\"\n            @prefix ex: <http://example.org/> .\n            ex:alice ex:name \"Alice\" .\n        \"#;\n        // Test prefix resolution\n    }\n    \n    #[test]\n    fn test_blank_node() {\n        let content = r#\"\n            _:alice <http://example.org/name> \"Alice\" .\n        \"#;\n        // Test blank node handling\n    }\n}\n```\n\n### Integration Tests\n- Test with real Turtle files from `tests/data/`\n- Test with large files (streaming)\n- Test error cases\n\n## Performance Considerations\n\n### Warm Path Operation\n- RDF parsing is **warm path** (not hot path)\n- No impact on ≤8 tick budget\n- Performance target: <500ms for typical files\n\n### Memory Usage\n- Streaming parser uses minimal memory\n- No need to load entire file into memory\n- Suitable for large RDF files\n\n## Next Steps\n\n1. ✅ Add dependencies to `Cargo.toml` files\n2. ✅ Implement `rio_turtle` parser\n3. ✅ Add error handling\n4. ✅ Update tests\n5. ✅ Integration testing\n6. ✅ Performance validation\n7. ✅ Documentation update\n\n## References\n\n- `rio_turtle` docs: https://docs.rs/rio_turtle/\n- `rio_api` docs: https://docs.rs/rio_api/\n- CONVO.txt references (lines 25518-25563)\n- Current simplified parser: `rust/knhk-etl/src/lib.rs` (lines 74-132)\n\n"
        }
    ]
}