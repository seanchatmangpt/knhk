{
    "sourceFile": "docs/construct8-rust-aot-optimizations.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1762370522340,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1762370522340,
            "name": "Commit-0",
            "content": "# Rust AOT/Compile-Time Optimizations for CONSTRUCT8 Hot Path\n\n## Overview\nAll optimizations that Rust can prepare on the warm/cold path to eliminate runtime overhead in the C hot path. Organized by impact and implementation complexity.\n\n## 1. Code Generation & Specialization (Zero Runtime Cost)\n\n### 1.1. Length-Specialized Function Generation\n**Current Runtime Cost:** `len_mask_bits = ((1ULL << len) - 1) & 0xFFULL` (~0.25 ticks)\n\n**Rust AOT Action:**\n- Generate specialized C functions for each `len` value: `{1, 2, 3, 4, 5, 6, 7, 8}`\n- Functions: `knhk_construct8_emit_8_len1()`, `knhk_construct8_emit_8_len8()`, etc.\n- Each function has `len_mask_bits` as compile-time constant (0 ticks)\n- For `len == 8`: Skip `len_mask` application entirely (compiler optimizes to no-op)\n\n**Savings:** ~0.25 ticks per call\n\n**Implementation:**\n```rust\n// rust/knhk-aot/src/codegen.rs\npub fn generate_len_specialized_functions() -> Vec<String> {\n    (1..=8).map(|len| {\n        let len_mask = (1u64 << len) - 1;\n        format!(\n            \"static inline size_t knhk_construct8_emit_8_len{}(...) {{\n                // len_mask_bits = {}ULL (compile-time constant)\n                const uint64_t len_mask_bits = {}ULL;\n                // ... rest of function with len_mask_bits precomputed\n            }}\",\n            len, len_mask, len_mask\n        )\n    }).collect()\n}\n```\n\n### 1.2. Constant-Specialized Function Generation\n**Current Runtime Cost:** `p_vec = vdupq_n_u64(p_const)` (~0.5 ticks per broadcast)\n\n**Rust AOT Action:**\n- Analyze common `p_const`/`o_const` values at compile time\n- Generate specialized functions: `knhk_construct8_emit_8_p_X_o_Y()`\n- Compiler can optimize broadcasts to immediate constants\n- For common constants (0, 1, small values), compiler may eliminate broadcasts\n\n**Savings:** ~0.5-1 ticks per call (if constants are common)\n\n**Implementation:**\n```rust\n// Track common p_const/o_const pairs\npub fn generate_constant_specialized_functions(\n    common_pairs: &[(u64, u64)]\n) -> Vec<String> {\n    common_pairs.iter().map(|(p, o)| {\n        format!(\n            \"static inline size_t knhk_construct8_emit_8_p_{}_o_{}(...) {{\n                // p_vec = vdupq_n_u64({}) - compiler optimizes to constant\n                const uint64x2_t p_vec = vdupq_n_u64({});\n                const uint64x2_t o_vec = vdupq_n_u64({});\n                // ... rest of function\n            }}\",\n            p, o, p, p, o\n        )\n    }).collect()\n}\n```\n\n### 1.3. Pattern-Specialized Function Generation\n**Current Runtime Cost:** 4 mask comparisons (~4 ticks)\n\n**Rust AOT Action:**\n- Analyze input patterns at compile time:\n  - `ALL_NONZERO`: All subjects are non-zero → skip mask generation\n  - `ALL_ZERO`: All subjects are zero → early return\n  - `SPARSE`: Mixed pattern → use optimized sparse path\n- Generate specialized functions for each pattern\n\n**Savings:** ~4 ticks for ALL_NONZERO pattern\n\n**Implementation:**\n```rust\npub enum PatternType {\n    AllNonZero,  // Skip mask generation entirely\n    AllZero,      // Early return (0 ticks)\n    Sparse,       // Optimized sparse computation\n    Dense,        // Standard computation\n}\n\npub fn generate_pattern_specialized_functions() -> Vec<String> {\n    vec![\n        // All non-zero: skip mask generation\n        \"static inline size_t knhk_construct8_emit_8_all_nonzero(...) {\n            // m0 = m1 = m2 = m3 = all_ones (compile-time constant)\n            const uint64x2_t m0 = all_ones;\n            // ... skip mask computation\n        }\".to_string(),\n        // All zero: early return\n        \"static inline size_t knhk_construct8_emit_8_all_zero(...) {\n            *out_mask = 0;\n            return 0;\n        }\".to_string(),\n    ]\n}\n```\n\n## 2. Precomputed Constants & Hints (Near-Zero Runtime Cost)\n\n### 2.1. Precomputed Length Mask Bits\n**Current Runtime Cost:** `len_mask_bits = ((1ULL << len) - 1) & 0xFFULL` (~0.25 ticks)\n\n**Rust AOT Action:**\n- Precompute `len_mask_bits` for known `len` values\n- Store in IR structure as hint field\n- Hot path uses precomputed value directly\n\n**Savings:** ~0.25 ticks\n\n**Implementation:**\n```rust\n// rust/knhk-hot/src/ffi.rs\n#[repr(C)]\npub struct Ir {\n    // ... existing fields\n    pub len_mask_hint: u64,  // Precomputed: ((1 << len) - 1) & 0xFF\n}\n\nimpl Ir {\n    pub fn new_construct8(len: u64, p: u64, o: u64) -> Self {\n        let len_mask = if len == 8 { 0xFF } else { (1 << len) - 1 };\n        Self {\n            // ... \n            len_mask_hint: len_mask,\n        }\n    }\n}\n```\n\n### 2.2. Zero-Position Hint Bitmask\n**Current Runtime Cost:** 4 mask comparisons (~4 ticks)\n\n**Rust AOT Action:**\n- Analyze input subjects at warm-path time\n- Precompute zero-position bitmask: `bit i = 1 if S[i] == 0, else 0`\n- Store in IR structure as hint\n- Hot path uses hint to skip unnecessary comparisons or use optimized paths\n\n**Savings:** ~2-4 ticks (depending on pattern)\n\n**Implementation:**\n```rust\n#[repr(C)]\npub struct Ir {\n    // ... existing fields\n    pub zero_hint: u8,  // Bitmask: bit i = 1 if subject[i] == 0\n}\n\n// Warm path analysis\npub fn analyze_zero_pattern(subjects: &[u64; 8]) -> u8 {\n    let mut hint = 0u8;\n    for (i, &s) in subjects.iter().enumerate() {\n        if s == 0 {\n            hint |= 1 << i;\n        }\n    }\n    hint\n}\n```\n\n### 2.3. Precomputed Broadcast Values\n**Current Runtime Cost:** 2 broadcasts (~1 tick)\n\n**Rust AOT Action:**\n- Precompute broadcast vectors for common `p_const`/`o_const` values\n- Store in lookup table or as immediate constants\n- Hot path uses precomputed vectors\n\n**Savings:** ~0.5-1 ticks (if values are common)\n\n**Implementation:**\n```rust\n// Precomputed broadcast vectors for common constants\npub const COMMON_BROADCASTS: &[(u64, [u64; 2])] = &[\n    (0, [0, 0]),\n    (1, [1, 1]),\n    // ... other common values\n];\n\npub fn get_broadcast_hint(constant: u64) -> Option<[u64; 2]> {\n    COMMON_BROADCASTS.iter()\n        .find(|(c, _)| *c == constant)\n        .map(|(_, vec)| *vec)\n}\n```\n\n## 3. Function Pointer Dispatch (Low Runtime Cost)\n\n### 3.1. Optimal Function Selection\n**Current Runtime Cost:** Generic function with runtime checks\n\n**Rust AOT Action:**\n- Analyze operation parameters at warm-path time\n- Select optimal specialized function variant\n- Store function pointer in IR structure\n- Hot path calls specialized function directly (no dispatch overhead)\n\n**Savings:** ~1-2 ticks (eliminates runtime checks)\n\n**Implementation:**\n```rust\n// rust/knhk-aot/src/dispatch.rs\npub type Construct8Fn = unsafe extern \"C\" fn(\n    *const u64, u64, u64, u64, u64,\n    *mut u64, *mut u64, *mut u64,\n    *mut u64\n) -> usize;\n\npub fn select_optimal_function(\n    len: u64,\n    p_const: u64,\n    o_const: u64,\n    zero_hint: u8\n) -> Construct8Fn {\n    match (len, zero_hint) {\n        (8, 0xFF) => knhk_construct8_emit_8_all_zero,  // All zero\n        (8, 0x00) => knhk_construct8_emit_8_all_nonzero,  // All non-zero\n        (8, _) => knhk_construct8_emit_8_len8,  // len=8 specialization\n        (len, _) => knhk_construct8_emit_8_lenN,  // Other len values\n    }\n}\n\n#[repr(C)]\npub struct Ir {\n    // ... existing fields\n    pub construct8_fn: Option<Construct8Fn>,  // AOT-selected function pointer\n}\n```\n\n## 4. Memory Layout & Alignment (Zero Runtime Cost)\n\n### 4.1. Guaranteed 64-Byte Alignment\n**Current Runtime Cost:** Alignment hints (`__builtin_assume_aligned`) - 0 ticks (compiler hint)\n\n**Rust AOT Action:**\n- Ensure all arrays allocated with 64-byte alignment\n- Use `#[repr(align(64))]` or aligned allocators\n- Verify alignment at allocation time (warm path)\n- No runtime alignment checks needed\n\n**Savings:** 0 ticks (eliminates need for runtime checks)\n\n**Implementation:**\n```rust\n// rust/knhk-hot/src/ffi.rs\n#[repr(align(64))]\npub struct AlignedArray<T>(pub T);\n\n// Ensure alignment at allocation\npub fn allocate_aligned_arrays() -> (\n    Box<AlignedArray<[u64; 8]>>,\n    Box<AlignedArray<[u64; 8]>>,\n    Box<AlignedArray<[u64; 8]>>\n) {\n    (\n        Box::new(AlignedArray([0; 8])),\n        Box::new(AlignedArray([0; 8])),\n        Box::new(AlignedArray([0; 8])),\n    )\n}\n```\n\n### 4.2. Pre-allocated Output Buffers\n**Current Runtime Cost:** Buffer allocation check (if not pre-allocated)\n\n**Rust AOT Action:**\n- Pre-allocate all output buffers at warm-path time\n- Ensure buffers are 64-byte aligned and sized correctly\n- Store buffer pointers in IR structure\n- Hot path uses pre-allocated buffers (no allocation overhead)\n\n**Savings:** ~0.5 ticks (eliminates allocation checks)\n\n**Implementation:**\n```rust\npub struct PreallocatedBuffers {\n    pub out_s: Box<AlignedArray<[u64; 8]>>,\n    pub out_p: Box<AlignedArray<[u64; 8]>>,\n    pub out_o: Box<AlignedArray<[u64; 8]>>,\n}\n\nimpl PreallocatedBuffers {\n    pub fn new() -> Self {\n        Self {\n            out_s: Box::new(AlignedArray([0; 8])),\n            out_p: Box::new(AlignedArray([0; 8])),\n            out_o: Box::new(AlignedArray([0; 8])),\n        }\n    }\n}\n```\n\n## 5. Input Analysis & Validation (Zero Runtime Cost)\n\n### 5.1. Precomputed Input Validation\n**Current Runtime Cost:** Validation checks in hot path (~0.5 ticks)\n\n**Rust AOT Action:**\n- Validate all inputs at warm-path time\n- Ensure `len <= 8`, buffers non-NULL, alignment correct\n- Set validation flags in IR structure\n- Hot path skips validation (trusts AOT validation)\n\n**Savings:** ~0.5 ticks\n\n**Implementation:**\n```rust\n#[repr(C)]\npub struct Ir {\n    // ... existing fields\n    pub validated: bool,  // AOT validation flag\n}\n\n// Warm path validation\npub fn validate_and_prepare_ir(ir: &mut Ir) -> Result<(), ValidationError> {\n    // Validate all constraints\n    if ir.len > 8 { return Err(ValidationError::InvalidLength); }\n    if ir.out_s.is_null() { return Err(ValidationError::NullBuffer); }\n    // ... other validations\n    \n    ir.validated = true;\n    Ok(())\n}\n```\n\n### 5.2. Precomputed Offset Validation\n**Current Runtime Cost:** Offset bounds checking\n\n**Rust AOT Action:**\n- Validate `off + len <= array_size` at warm-path time\n- Ensure no out-of-bounds access\n- Store validation result in IR\n- Hot path trusts AOT validation\n\n**Savings:** ~0.25 ticks\n\n## 6. Pattern Caching (Medium Runtime Cost, High Benefit)\n\n### 6.1. Mask Pattern Cache\n**Current Runtime Cost:** Full mask computation (~4 ticks)\n\n**Rust AOT Action:**\n- Cache mask patterns for repeated input patterns\n- Use hash of input subjects as cache key\n- Store cached mask in IR structure\n- Hot path reuses cached mask if available\n\n**Trade-off:** Cache lookup (~0.5 ticks) vs mask computation (~4 ticks)\n\n**Implementation:**\n```rust\nuse std::collections::HashMap;\n\npub struct MaskCache {\n    cache: HashMap<u64, u64>,  // hash(subjects) -> mask\n}\n\nimpl MaskCache {\n    pub fn get_or_compute(&mut self, subjects: &[u64; 8]) -> u64 {\n        let key = self.hash_subjects(subjects);\n        *self.cache.entry(key)\n            .or_insert_with(|| self.compute_mask(subjects))\n    }\n    \n    fn hash_subjects(&self, subjects: &[u64; 8]) -> u64 {\n        // Fast hash of subjects\n        subjects.iter().fold(0, |acc, &s| acc ^ s)\n    }\n    \n    fn compute_mask(&self, subjects: &[u64; 8]) -> u64 {\n        // Compute mask (warm path only)\n        subjects.iter().enumerate()\n            .fold(0, |acc, (i, &s)| acc | ((s != 0) as u64) << i)\n    }\n}\n```\n\n## 7. Compile-Time Code Generation (Build-Time)\n\n### 7.1. Macro-Based Code Generation\n**Current Runtime Cost:** Generic code paths\n\n**Rust AOT Action:**\n- Use Rust macros to generate C code at build time\n- Generate specialized functions for all combinations:\n  - 8 len values × N pattern types × M constant pairs\n- Compile generated C code into library\n- Hot path uses specialized functions\n\n**Savings:** Varies by specialization (0-4 ticks per call)\n\n**Implementation:**\n```rust\n// rust/knhk-aot/build.rs\nuse std::fs::File;\nuse std::io::Write;\n\nfn main() {\n    let mut generated = File::create(\"src/generated/construct8_specialized.c\").unwrap();\n    \n    // Generate all combinations\n    for len in 1..=8 {\n        for pattern in &[PatternType::AllNonZero, PatternType::Sparse, PatternType::Dense] {\n            writeln!(generated, \"{}\", generate_function(len, pattern)).unwrap();\n        }\n    }\n}\n```\n\n### 7.2. Template Specialization\n**Current Runtime Cost:** Generic template instantiation\n\n**Rust AOT Action:**\n- Use Rust to generate C template instantiations\n- Generate specialized code for common cases\n- Compile specialized versions into library\n- Hot path uses appropriate specialization\n\n**Savings:** ~1-2 ticks (eliminates template overhead)\n\n## 8. Summary: Total Potential Savings\n\n| Optimization | Current Cost | Rust AOT Cost | Savings | Implementation Complexity |\n|--------------|--------------|---------------|---------|---------------------------|\n| Length specialization | 0.25 ticks | 0 ticks | 0.25 ticks | Low |\n| Constant specialization | 1 tick | 0 ticks | 1 tick | Medium |\n| Pattern specialization (all non-zero) | 4 ticks | 0 ticks | 4 ticks | Low |\n| Zero-position hint | 4 ticks | 0 ticks | 2-4 ticks | Medium |\n| Function pointer dispatch | 1-2 ticks | 0 ticks | 1-2 ticks | Medium |\n| Precomputed len_mask | 0.25 ticks | 0 ticks | 0.25 ticks | Low |\n| Alignment guarantees | 0 ticks | 0 ticks | 0 ticks | Low |\n| Pre-allocated buffers | 0.5 ticks | 0 ticks | 0.5 ticks | Low |\n| Input validation | 0.5 ticks | 0 ticks | 0.5 ticks | Low |\n| Mask pattern cache | 4 ticks | 0.5 ticks | 3.5 ticks | Medium |\n\n**Total Potential Savings:** ~10-15 ticks (bringing 42 ticks down to ~27-32 ticks)\n\n**Best Case Scenario (All Optimizations):**\n- Length specialization: -0.25 ticks\n- Pattern specialization (all non-zero): -4 ticks\n- Zero-position hint: -2 ticks\n- Function dispatch: -1 tick\n- Precomputed constants: -0.5 ticks\n- **Total: ~-7.75 ticks**\n\n**Remaining Cost:** ~34 ticks (still exceeds 8-tick budget, but significantly improved)\n\n## 9. Implementation Priority\n\n### Priority 1: High Impact, Low Complexity\n1. ✅ Precomputed `len_mask_bits` (0.25 ticks saved)\n2. ✅ Pre-allocated buffers (0.5 ticks saved)\n3. ✅ Length-specialized functions (0.25 ticks saved)\n4. ✅ Pattern specialization for all-nonzero (4 ticks saved)\n\n### Priority 2: Medium Impact, Medium Complexity\n5. ✅ Zero-position hint (2-4 ticks saved)\n6. ✅ Function pointer dispatch (1-2 ticks saved)\n7. ✅ Constant specialization (1 tick saved)\n\n### Priority 3: Advanced (Long-term)\n8. Mask pattern cache (3.5 ticks saved, but requires cache management)\n9. Build-time code generation (varies, but high maintenance cost)\n\n## 10. Files to Create/Modify\n\n**Rust Warm/Cold Path:**\n- `rust/knhk-aot/src/codegen.rs` - Code generation for specialized functions\n- `rust/knhk-aot/src/pattern_analyzer.rs` - Pattern detection and analysis\n- `rust/knhk-aot/src/dispatch.rs` - Function pointer dispatch logic\n- `rust/knhk-aot/src/hints.rs` - Precomputed hint generation\n- `rust/knhk-hot/src/ffi.rs` - Add AOT hint fields to IR structure\n\n**C Hot Path:**\n- `src/simd/construct.h` - Add specialized function variants\n- `include/knhk/types.h` - Add AOT hint fields to IR structure\n- `include/knhk/eval.h` - Add function pointer dispatch\n\n**Build System:**\n- `rust/knhk-aot/build.rs` - Build-time code generation\n\n"
        }
    ]
}