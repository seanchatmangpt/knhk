{
    "sourceFile": "docs/api.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1762310211084,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1762310211084,
            "name": "Commit-0",
            "content": "# API Reference\n\n## Public API\n\n### Types\n\n#### knhk_op_t\nOperation types for queries:\n```c\ntypedef enum {\n  KNHK_OP_ASK_SP = 1,      // ASK existence check\n  KNHK_OP_COUNT_SP_GE = 2, // COUNT >= k\n  KNHK_OP_ASK_SPO = 3,     // Triple matching\n  KNHK_OP_SELECT_SP = 4    // SELECT query\n} knhk_op_t;\n```\n\n#### knhk_context_t\nContext holding SoA arrays and metadata:\n```c\ntypedef struct {\n  uint64_t *S;           // Subject array (must be NROWS aligned)\n  uint64_t *P;           // Predicate array\n  uint64_t *O;           // Object array\n  size_t triple_count;   // Number of loaded triples\n  knhk_pred_run_t run;  // Predicate run metadata\n} knhk_context_t;\n```\n\n#### knhk_hook_ir_t\nQuery representation (Hook IR):\n```c\ntypedef struct {\n  knhk_op_t op;         // Operation type\n  uint64_t s, p, o, k;   // Subject, predicate, object, threshold\n  uint64_t *select_out;  // SELECT output buffer (NULL for ASK/COUNT)\n  size_t select_capacity; // SELECT buffer capacity\n} knhk_hook_ir_t;\n```\n\n#### knhk_pred_run_t\nPredicate run metadata:\n```c\ntypedef struct {\n  uint64_t pred;  // Predicate ID\n  uint64_t off;   // Offset in arrays\n  uint64_t len;   // Length (must be ≤8 for hot path)\n} knhk_pred_run_t;\n```\n\n## Functions\n\n### Context Management\n\n#### knhk_init_context\nInitialize context with arrays:\n```c\nvoid knhk_init_context(knhk_context_t *ctx, uint64_t *S, uint64_t *P, uint64_t *O);\n```\n- `ctx`: Context to initialize\n- `S`, `P`, `O`: Arrays (must be 64-byte aligned, size NROWS)\n\n#### knhk_load_rdf\nLoad RDF file into context:\n```c\nint knhk_load_rdf(knhk_context_t *ctx, const char *filename);\n```\n- Returns: 1 on success, 0 on failure\n- Automatically sets predicate run metadata\n- Supports Turtle format\n\n### Query Evaluation\n\n#### knhk_eval_bool\nEvaluate boolean query (inline, hot path):\n```c\nstatic inline int knhk_eval_bool(const knhk_context_t *ctx, const knhk_hook_ir_t *ir);\n```\n- Returns: 1 if true, 0 if false\n- Inline function for zero-overhead hot path\n- Supports ASK_SP, COUNT_SP_GE, ASK_SPO operations\n\n#### knhk_eval_select\nEvaluate SELECT query:\n```c\nsize_t knhk_eval_select(const knhk_context_t *ctx, const knhk_hook_ir_t *ir);\n```\n- Returns: Number of results written to `ir->select_out`\n- Currently exceeds 8-tick budget\n\n### Benchmarking\n\n#### knhk_bench_eval\nBenchmark query execution:\n```c\ndouble knhk_bench_eval(const knhk_context_t *ctx, const knhk_hook_ir_t *ir, int iters);\n```\n- Returns: Nanoseconds per operation\n- Warms cache before measurement\n\n### Clock Utilities\n\n#### knhk_rd_ticks\nRead CPU ticks:\n```c\nuint64_t knhk_rd_ticks(void);\n```\n- ARM64: Uses `cntvct_el0`\n- x86_64: Uses `rdtsc`\n\n#### knhk_ticks_hz\nGet ticks per second:\n```c\ndouble knhk_ticks_hz(void);\n```\n- ARM64: Reads `cntfrq_el0`\n- x86_64: Uses `CPU_GHZ` env var or defaults to 4.0 GHz\n\n## Usage Examples\n\n### Basic ASK Query\n```c\n#include \"knhk.h\"\n\n// Allocate aligned arrays\nuint64_t ALN S[NROWS], P[NROWS], O[NROWS];\nknhk_context_t ctx;\nknhk_init_context(&ctx, S, P, O);\n\n// Load RDF data\nknhk_load_rdf(&ctx, \"data.ttl\");\n\n// Create ASK query\nknhk_hook_ir_t ir = {\n  .op = KNHK_OP_ASK_SP,\n  .s = ctx.S[0],\n  .p = ctx.run.pred,\n  .k = 0,\n  .o = 0,\n  .select_out = NULL,\n  .select_capacity = 0\n};\n\n// Execute\nint result = knhk_eval_bool(&ctx, &ir);\n```\n\n### COUNT Query\n```c\nknhk_hook_ir_t count_ir = {\n  .op = KNHK_OP_COUNT_SP_GE,\n  .s = subject_id,\n  .p = predicate_id,\n  .k = 1,  // Check if count >= 1\n  .o = 0,\n  .select_out = NULL,\n  .select_capacity = 0\n};\n\nint has_at_least_one = knhk_eval_bool(&ctx, &count_ir);\n```\n\n### Triple Matching\n```c\nknhk_hook_ir_t spo_ir = {\n  .op = KNHK_OP_ASK_SPO,\n  .s = subject_id,\n  .p = predicate_id,\n  .o = object_id,\n  .k = 0,\n  .select_out = NULL,\n  .select_capacity = 0\n};\n\nint triple_exists = knhk_eval_bool(&ctx, &spo_ir);\n```\n\n## Compilation Constants\n\n- `NROWS`: Maximum rows per predicate run (default: 8)\n- Must be ≤8 for hot path optimization\n- Enables fully unrolled SIMD when NROWS==8\n\n## Performance Notes\n\n- All hot path functions are inline for zero overhead\n- SIMD functions are header-only inline (NROWS==8)\n- Context must be initialized before use\n- Arrays must be 64-byte aligned\n\n"
        }
    ]
}