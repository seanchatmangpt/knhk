{
    "sourceFile": "docs/architecture.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1762388082049,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1762388326970,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -150,8 +150,18 @@\n - OWL reasoning\n - Full SPARQL compliance\n - Lockchain integration\n \n+**Cold Path** (Rust-native hooks engine):\n+- Single hook execution (2ns target)\n+- Batch hook evaluation (parallel execution)\n+- Guard function: μ ⊣ H (partial)\n+- Provenance: hash(A) = hash(μ(O))\n+- Invariant preservation: preserve(Q)\n+- SPARQL ASK query execution via oxigraph\n+- Cryptographic receipt generation (SHA-256)\n+- Thread-safe hook registry\n+\n ### 5. Evaluation Layer\n \n - **Hook IR**: Lightweight query representation\n - **Context**: SoA arrays + predicate run metadata\n@@ -168,8 +178,46 @@\n - **knhk_hooks**: Hook installation and management\n - **knhk_epoch**: Epoch scheduling (Λ ≺-total, τ ≤ 8)\n - **knhk_route**: Action routing to downstream systems\n \n+### 7. Hooks Engine (Rust-native)\n+\n+**Rust-native hooks engine** (`rust/knhk-unrdf/src/hooks_native.rs`):\n+\n+**Architecture**:\n+- **Native Store**: oxigraph-based RDF storage\n+- **Hook Registry**: Thread-safe registry (`Arc<Mutex<HashMap>>`)\n+- **Guard Function**: `μ ⊣ H` (partial) - Validates `O ⊨ Σ` before `A = μ(O)`\n+- **Batch Execution**: Parallel evaluation via Rayon\n+- **Receipt Generation**: SHA-256 cryptographic receipts\n+\n+**Use Cases**:\n+1. **Single Hook Execution** (2ns target): Guard validation before canonicalization\n+2. **Batch Hook Evaluation** (Cold Path): Parallel execution for multiple hooks\n+\n+**Key Laws Implemented**:\n+- `Guard: μ ⊣ H` (partial)\n+- `Invariant: preserve(Q)`\n+- `Provenance: hash(A) = hash(μ(O))`\n+- `Order: Λ` is `≺`-total\n+- `Idempotence: μ ∘ μ = μ`\n+- `Merge: Π` is `⊕`-monoid\n+- `Typing: O ⊨ Σ`\n+\n+**Components**:\n+- `hooks_native.rs`: Core hooks engine implementation\n+- `query_native.rs`: SPARQL query execution (oxigraph)\n+- `canonicalize.rs`: RDF canonicalization and hashing\n+- `cache.rs`: Query result caching (LRU)\n+- `hooks_native_ffi.rs`: FFI exports for C integration\n+\n+**Test Coverage**: 31 tests\n+- 14 Chicago TDD tests (laws)\n+- 17 error validation tests\n+- 7 stress tests\n+\n+See [Hooks Engine: 2ns Use Cases](hooks-engine-2ns-use-cases.md) for complete documentation.\n+\n ## Architecture Diagram\n \n See `architecture.mmd` for visual representation.\n \n"
                }
            ],
            "date": 1762388082049,
            "name": "Commit-0",
            "content": "# Architecture\n\n## Formal Mathematical Foundations\n\nKNHK's architecture is grounded in formal mathematical laws that define its behavior. These laws give rise to emergent properties that enable safe parallelism, cryptographic verification, and deterministic execution.\n\n**Key Formal Properties**:\n- **Idempotence** (μ∘μ = μ): Safe retry semantics without coordination\n- **Shard Distributivity** (μ(O ⊔ Δ) = μ(O) ⊔ μ(Δ)): Parallel evaluation equivalence\n- **Sheaf Property** (glue(Cover(O)) = Γ(O)): Local-to-global consistency\n- **Provenance** (hash(A) = hash(μ(O))): Cryptographic verification\n- **Epoch Containment** (μ ⊂ τ): Time-bounded execution\n\nSee [Formal Mathematical Foundations](formal-foundations.md) for complete formal treatment.\n\n---\n\n## System Overview\n\nKNHK (v0.5.0) implements a multi-tier architecture with production-ready infrastructure:\n\n1. **Hot Path Engine** (C) - ≤8 tick query execution (ASK, COUNT, COMPARE, VALIDATE)\n2. **Warm Path Engine** (Rust) - ≤500ms emit operations (CONSTRUCT8)\n3. **Connector Framework** (Rust) - Enterprise data source integration\n4. **ETL Pipeline** (Rust) - Ingest → Transform → Load → Reflex → Emit\n5. **Reflexive Control Layer** (Erlang) - Schema, invariants, receipts, routing\n6. **Observability** (OTEL) - Metrics, tracing, span generation\n\nQueries route to hot path (≤8 ticks), warm path (≤500ms), or cold path (full SPARQL engine) based on operation type and complexity.\n\n## Modular Code Organization\n\n### Header Structure\n\nThe public API is organized into modular headers for maintainability:\n\n```\ninclude/\n├── knhk.h              # Main umbrella header (includes all components)\n└── knhk/\n    ├── types.h          # Type definitions (enums, structs, constants)\n    ├── eval.h           # Query evaluation functions (eval_bool, eval_construct8)\n    ├── receipts.h       # Receipt operations (receipt_merge)\n    └── utils.h          # Utility functions (init_ctx, load_rdf, clock utilities)\n```\n\n**Usage**: Include only `knhk.h` - it automatically includes all sub-modules:\n```c\n#include \"knhk.h\"  // Includes all API components\n```\n\n### Source Structure\n\nSIMD operations are organized into focused modules:\n\n```\nsrc/\n├── simd.h               # SIMD umbrella header (includes all SIMD modules)\n├── simd/\n│   ├── common.h         # Common infrastructure (includes, declarations)\n│   ├── existence.h      # ASK operations (exists_8, exists_o_8, spo_exists_8)\n│   ├── count.h          # COUNT operations (count_8)\n│   ├── compare.h        # Comparison operations (compare_o_8)\n│   ├── select.h         # SELECT operations (select_gather_8)\n│   ├── validate.h       # Datatype validation (validate_datatype_sp_8)\n│   └── construct.h      # CONSTRUCT8 operations (construct8_emit_8)\n├── simd.c               # Variable-length SIMD implementations\n├── core.c               # Core operations (batch execution)\n├── rdf.c                # RDF parsing (Turtle format)\n└── clock.c              # Timing utilities and span ID generation\n```\n\n### Test Structure\n\nTests are organized into focused suites:\n\n```\ntests/\n├── chicago_enterprise_use_cases.c    # Main enterprise test runner\n├── chicago_basic_operations.c        # Basic operations (tests 1,2,5)\n├── chicago_cardinality.c             # Cardinality tests (tests 3,6,7,9)\n├── chicago_object_operations.c       # Object operations (tests 8,10,11,12)\n├── chicago_advanced.c                # Advanced operations (tests 4,13-19)\n├── chicago_test_helpers.c           # Shared test infrastructure\n├── chicago_test_helpers.h            # Test helper declarations\n├── chicago_v1_test.c                 # v1.0 test runner\n├── chicago_v1_receipts.c             # Receipt tests\n├── chicago_v1_operations.c            # Operation tests (CONSTRUCT8, batch)\n├── chicago_v1_validation.c           # Validation tests (guards, constants)\n├── chicago_integration_v2.c          # Integration test runner\n├── chicago_integration_core.c        # Core integration tests\n├── chicago_integration_systems.c     # System integration (lockchain, OTEL)\n└── chicago_integration_advanced.c    # Advanced integration tests\n```\n\n## Core Components\n\n### 1. Data Layer (SoA Layout)\n\nTriples are stored in Structure-of-Arrays format:\n- `S[]` - Subject array (64-byte aligned)\n- `P[]` - Predicate array (64-byte aligned)\n- `O[]` - Object array (64-byte aligned)\n\nAll arrays are 64-byte aligned for optimal cache line access and SIMD operations.\n\n### 2. Connector Framework (v0.4.0)\n\n**Dark Matter 80/20 Connector Framework**:\n- Kafka connector with rdkafka integration\n- Salesforce connector with reqwest integration\n- HTTP, File, SAP connector support\n- Circuit breaker pattern for resilience\n- Health checking and metrics\n- Guard validation (max_run_len ≤ 8, max_batch_size, max_lag_ms)\n\n### 3. ETL Pipeline (v0.4.0)\n\n**Five-Stage Pipeline**:\n- **Ingest**: Connector polling, RDF/Turtle parsing, JSON-LD support\n- **Transform**: Schema validation (O ⊨ Σ), IRI hashing (FNV-1a), typed triples\n- **Load**: Predicate run grouping, SoA conversion, 64-byte alignment\n- **Reflex**: Hot path execution (≤8 ticks), receipt generation, receipt merging (⊕)\n- **Emit**: Lockchain writing (Merkle-linked), downstream APIs (webhooks, Kafka, gRPC)\n\n### 4. Query Layer\n\n**Hot Path** (≤8 ticks, ≤2ns):\n- Simple ASK queries\n- COUNT queries (≤8 elements)\n- Triple matching (S-P-O)\n- Branchless SIMD execution\n- Fully unrolled for NROWS=8\n- Batch execution (≤8 hooks)\n\n**Warm Path** (≤500ms, Rust + oxigraph):\n- SPARQL SELECT, ASK, CONSTRUCT, DESCRIBE queries\n- Data size ≤10K triples\n- Basic SPARQL features (FILTER, OPTIONAL, UNION)\n- Query result caching (LRU cache, 1000 entries)\n- Query plan caching (parsed SPARQL queries)\n- OTEL metrics and observability\n- Automatic path selection based on query complexity\n\n**Cold Path** (unrdf):\n- Complex queries (JOINs, OPTIONAL, UNION)\n- Multi-predicate queries\n- UPDATE queries\n- SHACL validation\n- OWL reasoning\n- Full SPARQL compliance\n- Lockchain integration\n\n### 5. Evaluation Layer\n\n- **Hook IR**: Lightweight query representation\n- **Context**: SoA arrays + predicate run metadata\n- **SIMD Operations**: ARM NEON / x86 AVX2\n- **Receipts**: Timing, provenance, span IDs (OTEL-compatible)\n\n### 6. Reflexive Control Layer (v0.4.0)\n\n**Erlang Supervision Tree**:\n- **knhk_sigma**: Schema registry (Σ management)\n- **knhk_q**: Invariant registry (Q constraints, preserve(Q))\n- **knhk_ingest**: Delta ingestion (O ⊔ Δ)\n- **knhk_lockchain**: Receipt storage (Merkle-linked)\n- **knhk_hooks**: Hook installation and management\n- **knhk_epoch**: Epoch scheduling (Λ ≺-total, τ ≤ 8)\n- **knhk_route**: Action routing to downstream systems\n\n## Architecture Diagram\n\nSee `architecture.mmd` for visual representation.\n\n## Data Structures\n\n### knhk_context_t\n```c\ntypedef struct {\n  const uint64_t *S;        // Subject array (KNHK_ALIGN aligned, KNHK_NROWS sized)\n  const uint64_t *P;        // Predicate array\n  const uint64_t *O;        // Object array\n  size_t triple_count;      // Number of loaded triples\n  knhk_pred_run_t run;     // Predicate run metadata\n} knhk_context_t;\n```\n\n### knhk_hook_ir_t\n```c\ntypedef struct {\n  knhk_op_t op;            // Operation type\n  uint64_t s, p, o, k;      // Subject, predicate, object, threshold\n  \n  // For CONSTRUCT8 only: preallocated output spans (8 rows max)\n  uint64_t *out_S;          // may be NULL for non-CONSTRUCT8\n  uint64_t *out_P;\n  uint64_t *out_O;\n  uint64_t out_mask;        // per-lane bitmask result (returned by μ)\n  \n  // Legacy SELECT support (cold path only, not in hot v1.0)\n  uint64_t *select_out;     // SELECT output buffer\n  size_t select_capacity;\n} knhk_hook_ir_t;\n```\n\n### knhk_receipt_t\n```c\ntypedef struct {\n  uint32_t ticks;    // ≤ 8\n  uint32_t lanes;    // SIMD width used\n  uint64_t span_id;  // OTEL-compatible id\n  uint64_t a_hash;   // hash(A) = hash(μ(O)) fragment\n} knhk_receipt_t;\n```\n\n## Execution Flow\n\n### Basic Query Flow\n1. **RDF Loading**: Parse RDF/Turtle files → SoA arrays\n2. **Predicate Run Detection**: Group triples by predicate (len ≤ 8)\n3. **Query Compilation**: SPARQL → Hook IR\n4. **Path Selection**: Hot path vs warm path vs cold path routing\n   - Hot path: Simple ASK, data size ≤8\n   - Warm path: SPARQL queries, data size ≤10K\n   - Cold path: Complex queries, SHACL, reasoning\n5. **Evaluation**: Branchless SIMD execution (hot) or SPARQL engine (warm/cold)\n6. **Result Return**: Boolean, count, or solution set result\n7. **Caching**: Query results cached for warm path (epoch-based invalidation)\n\n### Enterprise Pipeline Flow (v0.3.0)\n1. **Connect**: Register connectors (Kafka, Salesforce, etc.)\n2. **Ingest**: Poll connectors → Raw triples\n3. **Transform**: Validate against Σ schema → Typed triples (IRI → u64)\n4. **Load**: Group by predicate → SoA arrays (64-byte aligned)\n5. **Reflex**: Execute hooks (μ) → Actions (A) + Receipts\n6. **Emit**: Write receipts to lockchain → Send actions to downstream APIs\n7. **Provenance**: hash(A) = hash(μ(O)) verified via receipts\n\n## Hot Path Requirements (v0.5.0)\n\n**Hot Path Operations** (≤8 ticks, ≤2ns):\n- ASK operations (ASK_SP, ASK_SPO, ASK_OP) - Existence checks\n- COUNT operations (COUNT_SP_GE/LE/EQ, COUNT_OP variants) - Cardinality validation\n- COMPARE operations (COMPARE_O_EQ/GT/LT/GE/LE) - Value comparisons\n- VALIDATION operations (UNIQUE_SP, VALIDATE_DATATYPE_SP/SPO) - Property validation\n\n**Warm Path Operations** (≤500ms):\n- CONSTRUCT8 operations (fixed-template emit) - Moved from hot path in v0.5.0\n\n**Path Selection**:\n- Hot path: Query operations that fit ≤8 tick budget\n- Warm path: Emit operations (CONSTRUCT8) that exceed 8-tick budget but complete in <500ms\n- Cold path: Complex queries requiring full SPARQL engine\n\n**Requirements**:\n- Predicate run size ≤8 elements (guard constraint enforced)\n- Simple operations (ASK, COUNT, triple match)\n- Data hot in L1 cache\n- Single predicate queries\n- Branchless operations (constant-time execution)\n- ≤8 ticks (Chatman Constant: 2ns = 8 ticks) for hot path\n- ≤500ms (p95) for warm path\n\n## Path Selection Logic\n\nKNHK automatically routes queries to the appropriate execution path based on query complexity and data size:\n\n### Hot Path Selection\n- Simple ASK queries (no FILTER, OPTIONAL, UNION)\n- COUNT queries (≤8 elements)\n- Data size ≤8 triples\n- Single predicate queries\n\n### Warm Path Selection (oxigraph)\n- SPARQL SELECT, ASK, CONSTRUCT, DESCRIBE queries\n- Data size ≤10K triples\n- Basic SPARQL features (FILTER, OPTIONAL, UNION)\n- No UPDATE queries\n- No SHACL validation\n- No OWL reasoning\n\n### Cold Path Selection (unrdf)\n- Complex queries exceeding warm path constraints\n- UPDATE queries\n- SHACL validation\n- OWL reasoning\n- Data size >10K triples\n- Very complex property paths or UNION patterns\n\n## Warm Path Integration (oxigraph)\n\nThe warm path uses [oxigraph](https://github.com/oxigraph/oxigraph), a Rust-native RDF store and SPARQL query engine, providing:\n\n- **Performance**: 10-14x faster than unrdf FFI (5-50ms vs 150-700ms)\n- **Caching**: LRU cache for query results (1000 entries)\n- **Query Plan Caching**: Parsed SPARQL queries cached to reduce parsing overhead\n- **Epoch-based Invalidation**: Cache automatically invalidated when data changes\n- **OTEL Integration**: Query latency, cache hit rate, and query count metrics\n- **Thread-safe**: Arc-based shared store for concurrent access\n- **Hot Path Integration**: Automatic routing to C hot path (≤2ns) for simple queries\n\n### Hot Path Routing\n\nSimple queries are automatically routed to C hot path functions for ≤2ns execution:\n\n- **ASK queries**: Routed to `knhk_eval_bool` C function\n- **COUNT queries**: Routed to C hot path COUNT operations\n- **Validation**: Tick budget verified (≤8 ticks) with automatic fallback\n- **Fallback**: Seamless fallback to warm path if hot path fails\n\n### Test Coverage\n\nComprehensive test suite with 83 Chicago TDD tests:\n\n- **Path Selector**: 100% coverage\n- **Query Module**: ~90% coverage  \n- **Graph Module**: ~80% coverage\n- **Executor**: ~80% coverage\n- **Overall**: ~80%+ coverage\n\nSee [Testing Documentation](testing.md) for details.\n\n### Performance Characteristics\n- **Query Execution**: 5-50ms (depending on data size and query complexity)\n- **Cache Hit**: 2-6μs (100x faster than cold execution)\n- **Target**: ≤500ms for warm path queries\n- **Cache Hit Rate**: Typically 60-80% for repeated queries\n\n## Cold Path Fallback\n\nQueries that exceed hot path or warm path constraints automatically fall back to unrdf (cold path) for full SPARQL engine execution.\n\n## Production Infrastructure (v0.4.0)\n\n**v0.4.0 Status**: Production-ready critical path features complete. See [v0.4.0 Status](archived/v0.4.0/v0.4.0-status.md) for complete details.\n\n**v0.5.0 Updates**:\n- ✅ CONSTRUCT8 moved to warm path (≤500ms budget)\n- ✅ Warm path engine implemented (`knhk-warm` crate)\n- ✅ Clear separation between hot path (query) and warm path (emit)\n- ✅ Warm path metrics and observability\n\n**Known Limitations**:\n- ⚠️ Configuration management incomplete - Deferred to v0.5.0 Phase 2\n- ⚠️ CLI documentation pending - Deferred to v0.5.0 Phase 3\n- ⚠️ Examples directory missing - Deferred to v0.5.0 Phase 3\n\n### Connector Framework\n- Real library integrations (rdkafka, reqwest)\n- Circuit breaker pattern for resilience\n- Health checking and metrics\n- Guard validation (max_run_len ≤ 8, max_batch_size, max_lag_ms)\n\n### ETL Pipeline\n- Production-ready stages (Ingest, Transform, Load, Reflex, Emit)\n- Schema validation (O ⊨ Σ)\n- Invariant checking (preserve(Q))\n- Receipt generation and merging (⊕)\n\n### Erlang Reflexive Control\n- Schema registry (knhk_sigma)\n- Invariant management (knhk_q)\n- Delta ingestion (knhk_ingest)\n- Lockchain (knhk_lockchain) with Merkle linking\n\n### Observability\n- OTEL span ID generation (not placeholders)\n- Metrics collection\n- Tracing support\n- Receipt provenance tracking\n\n## Modular Design Benefits\n\n- **Maintainability**: Clear separation of concerns\n- **Testability**: Focused test suites for each component\n- **Performance**: Hot path isolated in inline headers\n- **Extensibility**: Easy to add new operations or test suites\n- **Code Size**: Reduced compilation unit sizes improve build times\n\n"
        }
    ]
}