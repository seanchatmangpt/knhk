{
    "sourceFile": "rust/knhk-unrdf/src/query.rs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1762384149574,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1762384149574,
            "name": "Commit-0",
            "content": "// knhk-unrdf: SPARQL query execution\n// Execute SPARQL queries via unrdf\n\nuse crate::error::{UnrdfError, UnrdfResult};\nuse crate::script::execute_unrdf_script;\nuse crate::state::get_state;\nuse crate::types::{QueryResult, SparqlQueryType};\n\n/// Detect SPARQL query type from query string\npub fn detect_query_type(query: &str) -> SparqlQueryType {\n    let query_upper = query.trim().to_uppercase();\n    \n    // Check for UPDATE operations first (INSERT/DELETE)\n    if query_upper.starts_with(\"INSERT\") || query_upper.starts_with(\"DELETE\") {\n        if query_upper.contains(\"INSERT\") {\n            return SparqlQueryType::Insert;\n        }\n        if query_upper.contains(\"DELETE\") {\n            return SparqlQueryType::Delete;\n        }\n        return SparqlQueryType::Insert; // Default to Insert for UPDATE\n    }\n    \n    // Check for query types\n    if query_upper.starts_with(\"ASK\") {\n        return SparqlQueryType::Ask;\n    }\n    if query_upper.starts_with(\"CONSTRUCT\") {\n        return SparqlQueryType::Construct;\n    }\n    if query_upper.starts_with(\"DESCRIBE\") {\n        return SparqlQueryType::Describe;\n    }\n    if query_upper.starts_with(\"SELECT\") {\n        return SparqlQueryType::Select;\n    }\n    \n    SparqlQueryType::Unknown\n}\n\n/// Execute SPARQL query via unrdf with automatic query type detection\npub fn query_sparql(query: &str) -> UnrdfResult<QueryResult> {\n    let query_type = detect_query_type(query);\n    query_sparql_with_type(query, query_type)\n}\n\n/// Execute SPARQL query with data to store first (for stateful operations)\n/// This combines store and query in a single script so data persists\npub fn query_sparql_with_data(query: &str, turtle_data: &str) -> UnrdfResult<QueryResult> {\n    let query_type = detect_query_type(query);\n    let state = get_state()?;\n    \n    let query_type_str = match query_type {\n        SparqlQueryType::Select => \"sparql-select\",\n        SparqlQueryType::Ask => \"sparql-ask\",\n        SparqlQueryType::Construct => \"sparql-construct\",\n        SparqlQueryType::Describe => \"sparql-describe\",\n        SparqlQueryType::Insert | SparqlQueryType::Delete => \"sparql-update\",\n        SparqlQueryType::Unknown => {\n            return Err(UnrdfError::InvalidInput(\"Unknown query type\".to_string()));\n        }\n    };\n    \n    let escaped_query = query.replace('\\\\', \"\\\\\\\\\").replace('`', \"\\\\`\").replace('$', \"\\\\$\");\n    let escaped_data = turtle_data.replace('\\\\', \"\\\\\\\\\").replace('`', \"\\\\`\").replace('$', \"\\\\$\");\n    \n    let script = format!(\n        r#\"\n        import {{ createDarkMatterCore }} from './src/knowledge-engine/knowledge-substrate-core.mjs';\n        import {{ parseTurtle }} from './src/knowledge-engine/parse.mjs';\n        \n        async function main() {{\n            const system = await createDarkMatterCore({{\n                enableKnowledgeHookManager: true,\n                enableLockchainWriter: false\n            }});\n        \n            // Store data first\n            const turtleData = `{}`;\n            const store = await parseTurtle(turtleData);\n            const quads = [];\n            store.forEach(q => quads.push(q));\n            await system.executeTransaction({{\n                additions: quads,\n                removals: [],\n                actor: 'knhk-rust'\n            }});\n        \n            // Then query\n            const query = `{}`;\n            const queryType = '{}';\n        \n            let results;\n            let resultData = {{ success: true, query_type: queryType }};\n        \n            try {{\n                if (queryType === 'sparql-ask') {{\n                    results = await system.query({{\n                        query: query,\n                        type: queryType\n                    }});\n                    resultData.boolean = results;\n                }} else if (queryType === 'sparql-construct' || queryType === 'sparql-describe') {{\n                    results = await system.query({{\n                        query: query,\n                        type: queryType\n                    }});\n                    const triples = [];\n                    for await (const quad of results) {{\n                        triples.push({{\n                            subject: quad.subject.value,\n                            predicate: quad.predicate.value,\n                            object: quad.object.value,\n                            graph: quad.graph ? quad.graph.value : null\n                        }});\n                    }}\n                    resultData.triples = triples;\n                }} else if (queryType === 'sparql-update') {{\n                    await system.query({{\n                        query: query,\n                        type: queryType\n                    }});\n                    resultData.success = true;\n                }} else {{\n                    // SELECT query\n                    results = await system.query({{\n                        query: query,\n                        type: queryType\n                    }});\n                    const bindings = [];\n                    for await (const binding of results) {{\n                        const bindingObj = {{}};\n                        for (const [key, value] of binding) {{\n                            bindingObj[key] = value.value;\n                        }}\n                        bindings.push(bindingObj);\n                    }}\n                    resultData.bindings = bindings;\n                }}\n        \n                console.log(JSON.stringify(resultData));\n            }} catch (err) {{\n                console.error(JSON.stringify({{\n                    success: false,\n                    query_type: queryType,\n                    error: err.message\n                }}));\n                process.exit(1);\n            }}\n        }}\n        \n        main().catch(err => {{\n            console.error(JSON.stringify({{\n                success: false,\n                error: err.message\n            }}));\n            process.exit(1);\n        }});\n        \"#,\n        escaped_data,\n        escaped_query,\n        query_type_str\n    );\n    \n    state.runtime.block_on(async {\n        let output = execute_unrdf_script(&script).await?;\n        // Extract JSON from output (unrdf prints initialization messages to stdout)\n        // Find the last line that looks like JSON (starts with { or [)\n        let json_line = output\n            .lines()\n            .rev()\n            .find(|line| line.trim().starts_with('{') || line.trim().starts_with('['))\n            .ok_or_else(|| UnrdfError::QueryFailed(format!(\"No JSON found in output. Full output: {}\", output)))?;\n        \n        let result: QueryResult = serde_json::from_str(json_line.trim())\n            .map_err(|e| UnrdfError::QueryFailed(format!(\"Failed to parse result: {} - JSON line: {}\", e, json_line)))?;\n        Ok(result)\n    })\n}\n\n/// Execute SPARQL query via unrdf with explicit query type\npub fn query_sparql_with_type(query: &str, query_type: SparqlQueryType) -> UnrdfResult<QueryResult> {\n    let state = get_state()?;\n    \n    let query_type_str = match query_type {\n        SparqlQueryType::Select => \"sparql-select\",\n        SparqlQueryType::Ask => \"sparql-ask\",\n        SparqlQueryType::Construct => \"sparql-construct\",\n        SparqlQueryType::Describe => \"sparql-describe\",\n        SparqlQueryType::Insert | SparqlQueryType::Delete => \"sparql-update\",\n        SparqlQueryType::Unknown => {\n            return Err(UnrdfError::InvalidInput(\"Unknown query type\".to_string()));\n        }\n    };\n    \n    let escaped_query = query.replace('\\\\', \"\\\\\\\\\").replace('`', \"\\\\`\").replace('$', \"\\\\$\");\n    \n    let script = format!(\n        r#\"\n        import {{ createDarkMatterCore }} from './src/knowledge-engine/knowledge-substrate-core.mjs';\n        \n        async function main() {{\n            const system = await createDarkMatterCore({{\n                enableKnowledgeHookManager: true,\n                enableLockchainWriter: false\n            }});\n        \n            const query = `{}`;\n            const queryType = '{}';\n        \n            let results;\n            let resultData = {{ success: true, query_type: queryType }};\n        \n            try {{\n                if (queryType === 'sparql-ask') {{\n                    results = await system.query({{\n                        query: query,\n                        type: queryType\n                    }});\n                    resultData.boolean = results;\n                }} else if (queryType === 'sparql-construct' || queryType === 'sparql-describe') {{\n                    results = await system.query({{\n                        query: query,\n                        type: queryType\n                    }});\n                    const triples = [];\n                    for await (const quad of results) {{\n                        triples.push({{\n                            subject: quad.subject.value,\n                            predicate: quad.predicate.value,\n                            object: quad.object.value,\n                            graph: quad.graph ? quad.graph.value : null\n                        }});\n                    }}\n                    resultData.triples = triples;\n                }} else if (queryType === 'sparql-update') {{\n                    await system.query({{\n                        query: query,\n                        type: queryType\n                    }});\n                    resultData.success = true;\n                }} else {{\n                    // SELECT query\n                    results = await system.query({{\n                        query: query,\n                        type: queryType\n                    }});\n                    const bindings = [];\n                    for await (const binding of results) {{\n                        const bindingObj = {{}};\n                        for (const [key, value] of binding) {{\n                            bindingObj[key] = value.value;\n                        }}\n                        bindings.push(bindingObj);\n                    }}\n                    resultData.bindings = bindings;\n                }}\n        \n                console.log(JSON.stringify(resultData));\n            }} catch (err) {{\n                console.error(JSON.stringify({{\n                    success: false,\n                    query_type: queryType,\n                    error: err.message\n                }}));\n                process.exit(1);\n            }}\n        }}\n        \n        main().catch(err => {{\n            console.error(JSON.stringify({{\n                success: false,\n                error: err.message\n            }}));\n            process.exit(1);\n        }});\n        \"#,\n        escaped_query,\n        query_type_str\n    );\n    \n    state.runtime.block_on(async {\n        let output = execute_unrdf_script(&script).await?;\n        // Extract JSON from output (unrdf prints initialization messages to stdout)\n        // Find the last line that looks like JSON (starts with { or [)\n        let json_line = output\n            .lines()\n            .rev()\n            .find(|line| line.trim().starts_with('{') || line.trim().starts_with('['))\n            .ok_or_else(|| UnrdfError::QueryFailed(format!(\"No JSON found in output. Full output: {}\", output)))?;\n        \n        let result: QueryResult = serde_json::from_str(json_line.trim())\n            .map_err(|e| UnrdfError::QueryFailed(format!(\"Failed to parse result: {} - JSON line: {}\", e, json_line)))?;\n        Ok(result)\n    })\n}\n\n"
        }
    ]
}