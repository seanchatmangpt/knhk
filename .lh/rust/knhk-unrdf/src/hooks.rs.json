{
    "sourceFile": "rust/knhk-unrdf/src/hooks.rs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1762384149575,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1762384149575,
            "name": "Commit-0",
            "content": "// knhk-unrdf: Hook management\n// Register, deregister, and execute knowledge hooks\n\nuse crate::error::{UnrdfError, UnrdfResult};\nuse crate::script::execute_unrdf_script;\nuse crate::state::get_state;\nuse crate::types::{HookDefinition, HookRegistryEntry, HookResult};\n\n/// Execute knowledge hook via unrdf\npub fn execute_hook(hook_name: &str, hook_query: &str) -> UnrdfResult<HookResult> {\n    let state = get_state()?;\n    \n    let script = format!(\n        r#\"\n        import {{ createDarkMatterCore, defineHook, registerHook }} from './src/knowledge-engine/index.mjs';\n        import {{ evaluateHook }} from './src/knowledge-engine/hook-management.mjs';\n        \n        async function main() {{\n            const system = await createDarkMatterCore({{\n                enableKnowledgeHookManager: true,\n                enableLockchainWriter: false\n            }});\n        \n            const hook = defineHook({{\n                meta: {{\n                    name: '{}',\n                    description: 'KNHK hook'\n                }},\n                when: {{\n                    kind: 'sparql-ask',\n                    query: `{}`\n                }},\n                run: async (event) => {{\n                    return {{ result: event.result ? 'Hook fired' : 'Hook not fired' }};\n                }}\n            }});\n        \n            await registerHook(hook);\n            const receipt = await evaluateHook(hook, {{ persist: false }});\n        \n            console.log(JSON.stringify({{\n                fired: receipt.fired || false,\n                result: receipt.result || null,\n                receipt: receipt.receipt || null\n            }}));\n        }}\n        \n        main().catch(err => {{\n            console.error(JSON.stringify({{ fired: false, result: null, error: err.message }}));\n            process.exit(1);\n        }});\n        \"#,\n        hook_name,\n        hook_query.replace('`', \"\\\\`\").replace('$', \"\\\\$\")\n    );\n    \n    state.runtime.block_on(async {\n        let output = execute_unrdf_script(&script).await?;\n        // Extract JSON from output (unrdf prints initialization messages to stdout)\n        let json_line = output\n            .lines()\n            .rev()\n            .find(|line| line.trim().starts_with('{') || line.trim().starts_with('['))\n            .ok_or_else(|| UnrdfError::HookFailed(format!(\"No JSON found in output. Full output: {}\", output)))?;\n        \n        let result: HookResult = serde_json::from_str(json_line.trim())\n            .map_err(|e| UnrdfError::HookFailed(format!(\"Failed to parse result: {} - JSON line: {}\", e, json_line)))?;\n        Ok(result)\n    })\n}\n\n/// Execute knowledge hook with data to store first (for stateful operations)\n/// This combines store and hook execution in a single script so data persists\npub fn execute_hook_with_data(hook_name: &str, hook_query: &str, turtle_data: &str) -> UnrdfResult<HookResult> {\n    let state = get_state()?;\n    \n    let escaped_query = hook_query.replace('`', \"\\\\`\").replace('$', \"\\\\$\");\n    let escaped_data = turtle_data.replace('\\\\', \"\\\\\\\\\").replace('`', \"\\\\`\").replace('$', \"\\\\$\");\n    \n    let script = format!(\n        r#\"\n        import {{ createDarkMatterCore, defineHook, registerHook }} from './src/knowledge-engine/index.mjs';\n        import {{ evaluateHook }} from './src/knowledge-engine/hook-management.mjs';\n        import {{ parseTurtle }} from './src/knowledge-engine/parse.mjs';\n        \n        async function main() {{\n            const system = await createDarkMatterCore({{\n                enableKnowledgeHookManager: true,\n                enableLockchainWriter: false\n            }});\n        \n            // Store data first\n            const turtleData = `{}`;\n            const store = await parseTurtle(turtleData);\n            const quads = [];\n            store.forEach(q => quads.push(q));\n            await system.executeTransaction({{\n                additions: quads,\n                removals: [],\n                actor: 'knhk-rust'\n            }});\n        \n            // Then execute hook\n            const hook = defineHook({{\n                meta: {{\n                    name: '{}',\n                    description: 'KNHK hook'\n                }},\n                when: {{\n                    kind: 'sparql-ask',\n                    query: `{}`\n                }},\n                run: async (event) => {{\n                    return {{ result: event.result ? 'Hook fired' : 'Hook not fired' }};\n                }}\n            }});\n        \n            await registerHook(hook);\n            const receipt = await evaluateHook(hook, {{ persist: false }});\n        \n            console.log(JSON.stringify({{\n                fired: receipt.fired || false,\n                result: receipt.result || null,\n                receipt: receipt.receipt || null\n            }}));\n        }}\n        \n        main().catch(err => {{\n            console.error(JSON.stringify({{ fired: false, result: null, error: err.message }}));\n            process.exit(1);\n        }});\n        \"#,\n        escaped_data,\n        hook_name,\n        escaped_query\n    );\n    \n    state.runtime.block_on(async {\n        let output = execute_unrdf_script(&script).await?;\n        // Extract JSON from output (unrdf prints initialization messages to stdout)\n        let json_line = output\n            .lines()\n            .rev()\n            .find(|line| line.trim().starts_with('{') || line.trim().starts_with('['))\n            .ok_or_else(|| UnrdfError::HookFailed(format!(\"No JSON found in output. Full output: {}\", output)))?;\n        \n        let result: HookResult = serde_json::from_str(json_line.trim())\n            .map_err(|e| UnrdfError::HookFailed(format!(\"Failed to parse result: {} - JSON line: {}\", e, json_line)))?;\n        Ok(result)\n    })\n}\n\n/// Register a hook with the system\npub fn register_hook(hook_json: &str) -> UnrdfResult<String> {\n    let state = get_state()?;\n    \n    let hook_def: HookDefinition = serde_json::from_str(hook_json)\n        .map_err(|e| UnrdfError::InvalidInput(format!(\"Invalid hook JSON: {}\", e)))?;\n    \n    let hook_id = hook_def.id.clone();\n    \n    let mut hooks = state.hooks.lock()\n        .map_err(|e| UnrdfError::InvalidInput(format!(\"Failed to acquire hooks lock: {}\", e)))?;\n    \n    let entry = HookRegistryEntry {\n        hook: hook_def.clone(),\n        registered: true,\n    };\n    \n    hooks.insert(hook_id.clone(), entry);\n    \n    // Register hook in unrdf system\n    let escaped_json = hook_json.replace('\\\\', \"\\\\\\\\\").replace('`', \"\\\\`\").replace('$', \"\\\\$\");\n    let script = format!(\n        r#\"\n        import {{ createDarkMatterCore, defineHook, registerHook }} from './src/knowledge-engine/index.mjs';\n        \n        async function main() {{\n            const system = await createDarkMatterCore({{\n                enableKnowledgeHookManager: true,\n                enableLockchainWriter: false\n            }});\n        \n            const hookDef = {};\n            const hook = defineHook(hookDef);\n            await registerHook(hook);\n        \n            console.log('SUCCESS');\n        }}\n        \n        main().catch(err => {{\n            console.error('ERROR:', err.message);\n            process.exit(1);\n        }});\n        \"#,\n        escaped_json\n    );\n    \n    state.runtime.block_on(async {\n        let output = execute_unrdf_script(&script).await?;\n        if output.contains(\"SUCCESS\") {\n            Ok(hook_id)\n        } else {\n            Err(UnrdfError::HookFailed(output))\n        }\n    })\n}\n\n/// Deregister a hook\npub fn deregister_hook(hook_id: &str) -> UnrdfResult<()> {\n    let state = get_state()?;\n    \n    let mut hooks = state.hooks.lock()\n        .map_err(|e| UnrdfError::InvalidInput(format!(\"Failed to acquire hooks lock: {}\", e)))?;\n    \n    hooks.remove(hook_id)\n        .ok_or_else(|| UnrdfError::InvalidInput(format!(\"Hook {} not found\", hook_id)))?;\n    \n    Ok(())\n}\n\n/// List all registered hooks\npub fn list_hooks() -> UnrdfResult<Vec<HookDefinition>> {\n    let state = get_state()?;\n    \n    let hooks = state.hooks.lock()\n        .map_err(|e| UnrdfError::InvalidInput(format!(\"Failed to acquire hooks lock: {}\", e)))?;\n    \n    let hook_list: Vec<HookDefinition> = hooks.values()\n        .filter(|entry| entry.registered)\n        .map(|entry| entry.hook.clone())\n        .collect();\n    \n    Ok(hook_list)\n}\n\n"
        }
    ]
}