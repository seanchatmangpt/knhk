{
    "sourceFile": "rust/knhk-warm/tests/graph.rs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1762384775734,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1762384775734,
            "name": "Commit-0",
            "content": "//! Chicago TDD tests for WarmPathGraph operations\n//! Tests load_from_file(), insert_triple(), insert_quads(), cache invalidation\n\nuse knhk_warm::WarmPathGraph;\nuse knhk_warm::query::execute_select;\nuse oxigraph::model::{GraphName, NamedNode, Quad, Term};\nuse std::fs::{File, remove_file};\nuse std::io::Write;\nuse std::path::PathBuf;\nuse tempfile::TempDir;\n\n#[test]\nfn test_load_from_file() {\n    let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\n    let file_path = temp_dir.path().join(\"test_data.ttl\");\n    \n    // Create test file\n    let mut file = File::create(&file_path).expect(\"Failed to create file\");\n    writeln!(file, \"<s1> <p1> <o1> .\").expect(\"Failed to write\");\n    writeln!(file, \"<s2> <p1> <o2> .\").expect(\"Failed to write\");\n    drop(file);\n    \n    let graph = WarmPathGraph::new().expect(\"Failed to create graph\");\n    let result = graph.load_from_file(&file_path);\n    \n    assert!(result.is_ok(), \"Should load from file successfully\");\n    assert_eq!(graph.size(), 2, \"Graph should contain 2 triples\");\n}\n\n#[test]\nfn test_load_from_file_nonexistent() {\n    let graph = WarmPathGraph::new().expect(\"Failed to create graph\");\n    let nonexistent_path = PathBuf::from(\"/nonexistent/path/to/file.ttl\");\n    \n    let result = graph.load_from_file(&nonexistent_path);\n    assert!(result.is_err(), \"Should fail for nonexistent file\");\n    \n    let error_msg = result.unwrap_err();\n    assert!(error_msg.contains(\"Failed to open\") || error_msg.contains(\"No such file\"),\n           \"Error should mention file issue: {}\", error_msg);\n}\n\n#[test]\nfn test_insert_triple() {\n    let graph = WarmPathGraph::new().expect(\"Failed to create graph\");\n    \n    assert_eq!(graph.size(), 0, \"Initial graph should be empty\");\n    \n    let result = graph.insert_triple(\n        \"http://example.org/s1\",\n        \"http://example.org/p1\",\n        \"http://example.org/o1\"\n    );\n    \n    assert!(result.is_ok(), \"Should insert triple successfully\");\n    assert_eq!(graph.size(), 1, \"Graph should contain 1 triple\");\n    \n    // Verify triple was inserted\n    let query = \"ASK { <http://example.org/s1> <http://example.org/p1> <http://example.org/o1> }\";\n    let ask_result = graph.query(query).expect(\"Query should succeed\");\n    \n    match ask_result {\n        oxigraph::sparql::QueryResults::Boolean(true) => {}\n        _ => panic!(\"ASK query should return true for inserted triple\"),\n    }\n}\n\n#[test]\nfn test_insert_triple_invalid_iri() {\n    let graph = WarmPathGraph::new().expect(\"Failed to create graph\");\n    \n    // Invalid IRI (contains spaces)\n    let result = graph.insert_triple(\n        \"invalid iri with spaces\",\n        \"http://example.org/p1\",\n        \"http://example.org/o1\"\n    );\n    \n    assert!(result.is_err(), \"Should fail for invalid IRI\");\n    let error_msg = result.unwrap_err();\n    assert!(error_msg.contains(\"Invalid\") || error_msg.contains(\"IRI\"),\n           \"Error should mention IRI issue: {}\", error_msg);\n}\n\n#[test]\nfn test_insert_triple_cache_invalidation() {\n    let graph = WarmPathGraph::new().expect(\"Failed to create graph\");\n    \n    // Load initial data\n    graph.load_from_turtle(\"<s1> <p1> <o1> .\").expect(\"Failed to load data\");\n    \n    // Execute query (cache it)\n    let query = \"SELECT ?s WHERE { ?s <p1> ?o }\";\n    let result1 = execute_select(&graph, query).expect(\"Query should succeed\");\n    let initial_size = result1.bindings.len();\n    \n    // Insert new triple\n    graph.insert_triple(\"<s2>\", \"<p1>\", \"<o2>\").expect(\"Failed to insert\");\n    \n    // Query should reflect new data (cache should be invalidated)\n    let result2 = execute_select(&graph, query).expect(\"Query should succeed\");\n    assert!(result2.bindings.len() > initial_size,\n           \"Result should reflect new triple: {} vs {}\",\n           result2.bindings.len(), initial_size);\n}\n\n#[test]\nfn test_insert_quads() {\n    let graph = WarmPathGraph::new().expect(\"Failed to create graph\");\n    \n    let s1 = NamedNode::new(\"http://example.org/s1\").expect(\"Valid IRI\");\n    let p1 = NamedNode::new(\"http://example.org/p1\").expect(\"Valid IRI\");\n    let o1 = NamedNode::new(\"http://example.org/o1\").expect(\"Valid IRI\");\n    \n    let s2 = NamedNode::new(\"http://example.org/s2\").expect(\"Valid IRI\");\n    let p2 = NamedNode::new(\"http://example.org/p2\").expect(\"Valid IRI\");\n    let o2 = NamedNode::new(\"http://example.org/o2\").expect(\"Valid IRI\");\n    \n    let quads = vec![\n        Quad::new(s1, p1, Term::NamedNode(o1), GraphName::DefaultGraph),\n        Quad::new(s2, p2, Term::NamedNode(o2), GraphName::DefaultGraph),\n    ];\n    \n    let result = graph.insert_quads(&quads);\n    assert!(result.is_ok(), \"Should insert quads successfully\");\n    assert_eq!(graph.size(), 2, \"Graph should contain 2 quads\");\n}\n\n#[test]\nfn test_insert_quads_empty() {\n    let graph = WarmPathGraph::new().expect(\"Failed to create graph\");\n    \n    let quads = vec![];\n    let result = graph.insert_quads(&quads);\n    \n    assert!(result.is_ok(), \"Should handle empty quads\");\n    assert_eq!(graph.size(), 0, \"Graph should remain empty\");\n}\n\n#[test]\nfn test_bump_epoch_cache_invalidation() {\n    let graph = WarmPathGraph::new().expect(\"Failed to create graph\");\n    \n    graph.load_from_turtle(\"<s1> <p1> <o1> .\").expect(\"Failed to load data\");\n    \n    let query = \"SELECT ?s WHERE { ?s <p1> ?o }\";\n    \n    // Execute query (cache it)\n    let _result1 = execute_select(&graph, query).expect(\"Query should succeed\");\n    \n    // Get initial metrics\n    let metrics_before = graph.get_metrics();\n    let cache_hits_before = metrics_before.cache_hits;\n    \n    // Bump epoch (should invalidate cache)\n    graph.bump_epoch();\n    \n    // Execute same query again\n    let _result2 = execute_select(&graph, query).expect(\"Query should succeed\");\n    \n    // Cache should be invalidated, so this should be a cache miss\n    let metrics_after = graph.get_metrics();\n    \n    // Total queries should increase\n    assert!(metrics_after.total_queries > metrics_before.total_queries,\n           \"Total queries should increase: {} vs {}\",\n           metrics_after.total_queries, metrics_before.total_queries);\n}\n\n#[test]\nfn test_load_from_turtle_and_insert() {\n    let graph = WarmPathGraph::new().expect(\"Failed to create graph\");\n    \n    // Load initial data\n    graph.load_from_turtle(\"<s1> <p1> <o1> .\").expect(\"Failed to load\");\n    assert_eq!(graph.size(), 1, \"Should have 1 triple\");\n    \n    // Insert additional triple\n    graph.insert_triple(\"<s2>\", \"<p1>\", \"<o2>\").expect(\"Failed to insert\");\n    assert_eq!(graph.size(), 2, \"Should have 2 triples\");\n    \n    // Verify both triples exist\n    let query = \"SELECT ?s WHERE { ?s <p1> ?o }\";\n    let result = execute_select(&graph, query).expect(\"Query should succeed\");\n    assert_eq!(result.bindings.len(), 2, \"Should find both triples\");\n}\n\n#[test]\nfn test_graph_size_consistency() {\n    let graph = WarmPathGraph::new().expect(\"Failed to create graph\");\n    \n    assert_eq!(graph.size(), 0, \"Empty graph should have size 0\");\n    \n    graph.load_from_turtle(\"<s1> <p1> <o1> .\").expect(\"Failed to load\");\n    assert_eq!(graph.size(), 1, \"Should have size 1\");\n    \n    graph.insert_triple(\"<s2>\", \"<p1>\", \"<o2>\").expect(\"Failed to insert\");\n    assert_eq!(graph.size(), 2, \"Should have size 2\");\n    \n    graph.insert_triple(\"<s3>\", \"<p1>\", \"<o3>\").expect(\"Failed to insert\");\n    assert_eq!(graph.size(), 3, \"Should have size 3\");\n}\n\n#[test]\nfn test_load_from_file_empty_file() {\n    let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\n    let file_path = temp_dir.path().join(\"empty.ttl\");\n    \n    // Create empty file\n    File::create(&file_path).expect(\"Failed to create file\");\n    \n    let graph = WarmPathGraph::new().expect(\"Failed to create graph\");\n    let result = graph.load_from_file(&file_path);\n    \n    // Empty file should be handled gracefully\n    assert!(result.is_ok(), \"Should handle empty file\");\n    assert_eq!(graph.size(), 0, \"Empty file should result in empty graph\");\n}\n\n#[test]\nfn test_load_from_file_invalid_turtle() {\n    let temp_dir = TempDir::new().expect(\"Failed to create temp dir\");\n    let file_path = temp_dir.path().join(\"invalid.ttl\");\n    \n    // Create file with invalid Turtle syntax\n    let mut file = File::create(&file_path).expect(\"Failed to create file\");\n    writeln!(file, \"This is not valid Turtle syntax\").expect(\"Failed to write\");\n    drop(file);\n    \n    let graph = WarmPathGraph::new().expect(\"Failed to create graph\");\n    let result = graph.load_from_file(&file_path);\n    \n    assert!(result.is_err(), \"Should fail for invalid Turtle\");\n    let error_msg = result.unwrap_err();\n    assert!(error_msg.contains(\"Failed to load\") || error_msg.contains(\"parse\"),\n           \"Error should mention parsing issue: {}\", error_msg);\n}\n\n"
        }
    ]
}